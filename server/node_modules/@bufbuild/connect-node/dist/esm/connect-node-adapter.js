// Copyright 2021-2023 Buf Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { Code, connectErrorFromReason, createConnectRouter, } from "@bufbuild/connect";
import { uResponseNotFound } from "@bufbuild/connect/protocol";
import { universalRequestFromNodeRequest, universalResponseToNodeResponse, } from "./node-universal-handler.js";
import { compressionBrotli, compressionGzip } from "./compression.js";
/**
 * Create a Node.js request handler from a ConnectRouter.
 *
 * The returned function is compatible with http.RequestListener and its equivalent for http2.
 */
export function connectNodeAdapter(options) {
    var _a;
    if (options.acceptCompression === undefined) {
        options.acceptCompression = [compressionGzip, compressionBrotli];
    }
    const router = createConnectRouter(options);
    options.routes(router);
    const prefix = (_a = options.requestPathPrefix) !== null && _a !== void 0 ? _a : "";
    const paths = new Map();
    for (const uHandler of router.handlers) {
        paths.set(prefix + uHandler.requestPath, uHandler);
    }
    return function nodeRequestHandler(req, res) {
        var _a, _b;
        const uHandler = paths.get((_a = req.url) !== null && _a !== void 0 ? _a : "");
        if (!uHandler) {
            ((_b = options.fallback) !== null && _b !== void 0 ? _b : fallback)(req, res);
            return;
        }
        const uReq = universalRequestFromNodeRequest(req, undefined);
        uHandler(uReq)
            .then((uRes) => universalResponseToNodeResponse(uRes, res))
            .catch((reason) => {
            if (connectErrorFromReason(reason).code == Code.Aborted) {
                return;
            }
            // eslint-disable-next-line no-console
            console.error(`handler for rpc ${uHandler.method.name} of ${uHandler.service.typeName} failed`, reason);
        });
    };
}
const fallback = (request, response) => {
    response.writeHead(uResponseNotFound.status);
    response.end();
};
