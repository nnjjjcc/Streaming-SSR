// Copyright 2021-2023 Buf Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import * as http2 from "http2";
import * as http from "http";
import * as https from "https";
import { Code, ConnectError } from "@bufbuild/connect";
import { nodeHeaderToWebHeader, webHeaderToNodeHeaders, } from "./node-universal-header.js";
import { connectErrorFromNodeReason, getNodeErrorProps, unwrapNodeErrorChain, } from "./node-error.js";
import { pipeTo } from "@bufbuild/connect/protocol";
/**
 * Create an HTTP client using the Node.js `http` or `https` package.
 *
 * The HTTP client is a simple function conforming to the type UniversalClientFn.
 * It takes an UniversalClientRequest as an argument, and returns a promise for
 * an UniversalClientResponse.
 */
export function createNodeHttp1Client(httpOptions) {
    return async function request(req) {
        const sentinel = createSentinel();
        return new Promise((resolve, reject) => {
            sentinel.catch((e) => {
                reject(e);
            });
            h1Request(sentinel, req.url, Object.assign(Object.assign({}, httpOptions), { headers: webHeaderToNodeHeaders(req.header), method: req.method, signal: req.signal }), (request) => {
                pipeTo(req.body, sinkRequest(sentinel, request), {
                    propagateDownStreamError: true,
                }).catch(sentinel.reject);
                request.on("response", (response) => {
                    var _a;
                    response.on("error", sentinel.reject);
                    response.on("abort", () => sentinel.reject(new ConnectError("node response aborted", Code.Aborted)));
                    response.on("timeout", () => sentinel.reject(new ConnectError("node response timed out", Code.Aborted)));
                    const trailer = new Headers();
                    resolve({
                        status: (_a = response.statusCode) !== null && _a !== void 0 ? _a : 0,
                        header: nodeHeaderToWebHeader(response.headers),
                        body: h1ResponseIterable(sentinel, response, trailer),
                        trailer,
                    });
                });
            });
        });
    };
}
/**
 * Create an HTTP client using the Node.js `http2` package.
 *
 * Note that the client is bound to the authority, and by default, it will close
 * the HTTP/2 session after the response is read to the end.
 *
 * The HTTP client is a simple function conforming to the type UniversalClientFn.
 * It takes an UniversalClientRequest as an argument, and returns a promise for
 * an UniversalClientResponse.
 */
export function createNodeHttp2Client(authority, keepSessionOpen, http2SessionOptions) {
    const sessionHolder = {
        options: http2SessionOptions,
        authority: new URL(authority).origin,
        keepOpen: keepSessionOpen,
        lastSession: undefined,
    };
    return async function request(req) {
        const sentinel = createSentinel(req.signal);
        return new Promise((resolve, reject) => {
            sentinel.catch((e) => {
                reject(e);
            });
            h2Request(sentinel, sessionHolder, req.url, req.method, webHeaderToNodeHeaders(req.header), req.signal, {}, (stream) => {
                void pipeTo(req.body, sinkRequest(sentinel, stream), {
                    propagateDownStreamError: true,
                }).catch(sentinel.reject);
                stream.on("response", (headers) => {
                    var _a;
                    const response = {
                        status: (_a = headers[":status"]) !== null && _a !== void 0 ? _a : 0,
                        header: nodeHeaderToWebHeader(headers),
                        body: h2ResponseIterable(sentinel, stream),
                        trailer: h2ResponseTrailer(stream),
                    };
                    resolve(response);
                });
            });
        });
    };
}
function h1Request(sentinel, url, options, onRequest) {
    let request;
    if (new URL(url).protocol.startsWith("https")) {
        request = https.request(url, options);
    }
    else {
        request = http.request(url, options);
    }
    request.on("error", sentinel.reject);
    request.on("abort", () => sentinel.reject(new ConnectError("node request aborted", Code.Aborted)));
    request.on("socket", function onRequestSocket(socket) {
        function onSocketConnect() {
            socket.off("connect", onSocketConnect);
            onRequest(request);
        }
        // If readyState is open, then socket is already open due to keepAlive, so
        // the 'connect' event will never fire so call onRequest explicitly
        if (socket.readyState === "open") {
            onRequest(request);
        }
        else {
            socket.on("connect", onSocketConnect);
        }
    });
}
function sinkRequest(sentinel, request) {
    return function write(iterable) {
        const it = iterable[Symbol.asyncIterator]();
        return new Promise((resolve, reject) => {
            sentinel.catch(reject);
            writeNext();
            function writeNext() {
                if (sentinel.isRejected()) {
                    return;
                }
                it.next().then((r) => {
                    if (r.done === true) {
                        request.end(resolve);
                        return;
                    }
                    request.write(r.value, "binary", function (e) {
                        if (e) {
                            if (request.writableEnded &&
                                unwrapNodeErrorChain(e)
                                    .map(getNodeErrorProps)
                                    .some((p) => p.code == "ERR_STREAM_WRITE_AFTER_END") &&
                                it.throw !== undefined) {
                                // If the server responds and closes the connection before the client has written the entire response
                                // body, we get an ERR_STREAM_WRITE_AFTER_END error code from Node.js here.
                                // We do want to notify the iterable of the error condition, but we do not want to reject our sentinel,
                                // because that would also affect the reading side.
                                it.throw(new ConnectError("stream closed", Code.Aborted)).catch(() => {
                                    //
                                });
                                return;
                            }
                            sentinel.reject(e);
                        }
                        else {
                            writeNext();
                        }
                    });
                }, (e) => {
                    sentinel.reject(e);
                });
            }
        });
    };
}
function h1ResponseIterable(sentinel, response, trailer) {
    const inner = response[Symbol.asyncIterator]();
    return {
        [Symbol.asyncIterator]() {
            return {
                async next() {
                    const r = await sentinel.race(inner.next());
                    if (r.done === true) {
                        nodeHeaderToWebHeader(response.trailers).forEach((value, key) => {
                            trailer.set(key, value);
                        });
                        sentinel.resolve();
                        await sentinel;
                    }
                    return r;
                },
                throw(e) {
                    sentinel.reject(e);
                    throw e;
                },
            };
        },
    };
}
function h2Request(sentinel, sessionHolder, url, method, headers, signal, options, onStream) {
    const requestUrl = new URL(url);
    if (requestUrl.origin !== sessionHolder.authority) {
        const message = `cannot make a request to ${requestUrl.origin}: the http2 session is connected to ${sessionHolder.authority}`;
        sentinel.reject(new ConnectError(message, Code.Internal));
        return;
    }
    if (sessionHolder.keepOpen &&
        sessionHolder.lastSession !== undefined &&
        !sessionHolder.lastSession.closed &&
        !sessionHolder.lastSession.destroyed) {
        return h2ConnectedSession(sessionHolder.lastSession);
    }
    const connectingSession = http2.connect(sessionHolder.authority, sessionHolder.options, h2ConnectedSession);
    connectingSession.on("error", h2SessionConnectError);
    function h2SessionConnectError(e) {
        sentinel.reject(e);
    }
    function h2ConnectedSession(session) {
        sessionHolder.lastSession = session;
        session.off("error", sentinel.reject);
        session.off("error", h2SessionConnectError);
        session.on("error", sentinel.reject);
        const stream = session.request(Object.assign(Object.assign({}, headers), { ":method": method, ":path": requestUrl.pathname }), options);
        sentinel
            .catch((reason) => {
            return new Promise((resolve) => {
                if (stream.closed) {
                    return resolve();
                }
                // Node.js http2 streams that are aborted via an AbortSignal close with
                // an RST_STREAM with code INTERNAL_ERROR.
                // To comply with the mapping between gRPC and HTTP/2 codes, we need to
                // close with code CANCEL.
                // See https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md#errors
                // See https://www.rfc-editor.org/rfc/rfc7540#section-7
                if (reason instanceof ConnectError && reason.code == Code.Canceled) {
                    return stream.close(http2.constants.NGHTTP2_CANCEL, resolve);
                }
                // For other reasons, INTERNAL_ERROR is the best fit.
                stream.close(http2.constants.NGHTTP2_INTERNAL_ERROR, resolve);
            });
        })
            .finally(() => {
            session.off("error", sentinel.reject);
            if (!sessionHolder.keepOpen) {
                session.close();
            }
        })
            .catch(() => {
            // We intentionally swallow sentinel rejection - errors must
            // propagate through the request or response iterables.
        });
        stream.on("error", function h2StreamError(e) {
            if (stream.writableEnded &&
                unwrapNodeErrorChain(e)
                    .map(getNodeErrorProps)
                    .some((p) => p.code == "ERR_STREAM_WRITE_AFTER_END")) {
                return;
            }
            sentinel.reject(e);
        });
        stream.on("abort", function h2StreamAbort() {
            sentinel.reject(new ConnectError("node request aborted", Code.Aborted));
        });
        onStream(stream);
    }
}
function h2ResponseTrailer(response) {
    const trailer = new Headers();
    response.on("trailers", (args) => {
        nodeHeaderToWebHeader(args).forEach((value, key) => {
            trailer.set(key, value);
        });
    });
    return trailer;
}
function h2ResponseIterable(sentinel, response) {
    const inner = response[Symbol.asyncIterator]();
    return {
        [Symbol.asyncIterator]() {
            return {
                async next() {
                    const r = await sentinel.race(inner.next());
                    if (r.done === true) {
                        sentinel.resolve();
                        await sentinel;
                    }
                    return r;
                },
                throw(e) {
                    sentinel.reject(e);
                    throw e;
                },
            };
        },
    };
}
function createSentinel(signal) {
    let res;
    let rej;
    let resolved = false;
    let rejected = false;
    const p = new Promise((resolve, reject) => {
        res = resolve;
        rej = reject;
    });
    const c = {
        resolve() {
            if (!resolved && !rejected) {
                resolved = true;
                res === null || res === void 0 ? void 0 : res();
            }
        },
        isResolved() {
            return resolved;
        },
        reject(reason) {
            if (!resolved && !rejected) {
                rejected = true;
                rej === null || rej === void 0 ? void 0 : rej(connectErrorFromNodeReason(reason));
            }
        },
        isRejected() {
            return rejected;
        },
        async race(promise) {
            const r = await Promise.race([promise, p]);
            if (r === undefined && resolved) {
                throw new ConnectError("sentinel completed early", Code.Internal);
            }
            return r;
        },
    };
    const s = Object.assign(p, c);
    function onSignalAbort() {
        c.reject(new ConnectError("operation was aborted via signal", Code.Canceled));
    }
    if (signal) {
        if (signal.aborted) {
            onSignalAbort();
        }
        else {
            signal.addEventListener("abort", onSignalAbort);
        }
        p.finally(() => signal.removeEventListener("abort", onSignalAbort)).catch(() => {
            // We intentionally swallow sentinel rejection - errors must
            // propagate through the request or response iterables.
        });
    }
    return s;
}
