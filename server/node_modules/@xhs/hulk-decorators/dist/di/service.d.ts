/// <reference types="node" />
import { Server } from 'http';
import { HulkContext, HulkState, CustomDecorator } from './interface';
import { MetadataType, MetadataKey, AsyncProperty } from './enum';
import { ParameterParser } from '../parameter';
import Koa = require('koa');
import bodyParser = require('koa-bodyparser');
import Router = require('find-my-way');
/**
 * check the original key if a metadata is sepecified.
 *
 * Requires three parameters:
 * - `keys` - sepecified metadata keys
 * - `metadataKey` - key associated with the metadata
 *
 */
export declare function isSpecifiedMetadata(keys: MetadataKey[], metadataKey: any): boolean;
/**
 * check and reveal the original key if a metadata is typed.
 *
 * Requires three parameters:
 * - `type` - metadata type
 * - `metadataKey` - key associated with the metadata
 * - `reveal` - `optional` - if `true` and right type passed, the original key associated with the metadata will be returned
 *
 */
export declare function isTypedMetadata<R extends boolean, V extends (R extends true ? string : boolean)>(type: MetadataType, metadataKey: any, reveal?: R): V;
/**
 * 为Hulk装饰器装饰的类或类中的元素添加元数据的方法（Reflect.defineMetadata的封装，添加了对Hulk特殊类型元数据的额外处理）
 *
 * 使用方式:
 * ```typescript
 * AttachMetadata(
 *   key,
 *   value,
 * )
 *
 * or
 *
 * AttachMetadata(
 *   key,
 *   value,
 *   type,
 * )
 * ```
 *
 */
export declare function AttachMetadata<T extends MetadataType, V extends (T extends MetadataType.MIDDLEWARE ? Koa.Middleware | Function | (Koa.Middleware | Function)[] : T extends MetadataType.PARAMETER ? ParameterParser : any)>(this: any, metadataKey: string, metadataValue: V, type?: T): CustomDecorator;
declare class HulkService {
    port: number;
    globalPrefix: string;
    private debug;
    private targetMap;
    private middlewareMap;
    private routeMap;
    private providerMap;
    private defaultRouterConfig;
    private log;
    private declareConstructorHandler;
    private declareOwnPropertiesHandler;
    private declare;
    private inject;
    construct<T = any>(target: Function, ...rawArgs: any[]): T;
    private prepare;
    /** @ignore */
    generateHulkDecorator(): ClassDecorator;
    /** @ignore */
    generateAsyncPropertyDecorator(asyncProperty: AsyncProperty): PropertyDecorator;
    /**
     * 入口
     *
     * 使用方式:
     * ```typescript
     * hulkService.lookup()
     * ```
     *
     */
    lookup<T = {}>(rawConfig?: Router.Config<Router.HTTPVersion.V1> & {
        port?: number;
        globalPrefix?: string;
        globalMiddlewares?: (Koa.Middleware | Function)[];
        scanControllers?: boolean;
        controllers?: Function[];
        beforeRouting?: (ctx: Koa.Context) => void;
        afterRespond?: (ctx: HulkContext<HulkState & T>) => void;
        bodyParserOptions?: bodyParser.Options;
    }): Promise<Server>;
}
export declare const hulkService: HulkService;
/**
 * 类装饰器，用来收集和整理controller上的所有元数据，是所有其他装饰器正确生效的前置条件
 *
 * 使用方式:
 * ```typescript
 * @Hulk()// Hulk装饰器需置于所有controller装饰器的上方以保证被最后调用，这样才能收集到controller上的所有元数据
 * export default class UserController {
 *   ...
 * }
 * ```
 *
 */
export declare function Hulk(): ClassDecorator;
/**
 * 属性装饰器，设置Hulk装饰器装饰的类中的属性随请求创建，同时在constructor中注入ctx
 *
 * 使用方式:
 * ```typescript
 * @AsyncContext()
 * ctx!: HulkContext
 * ```
 *
 */
export declare function AsyncContext(): PropertyDecorator;
/**
 * 属性装饰器，设置Hulk装饰器装饰的类中的属性随请求创建，同时在constructor中注入ctx.state.store
 *
 * 使用方式:
 * ```typescript
 * @AsyncStore()
 * store!: Record<string, unknown>
 * ```
 *
 */
export declare function AsyncStore(): PropertyDecorator;
export {};
