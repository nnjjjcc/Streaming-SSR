"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AsyncStore = exports.AsyncContext = exports.Hulk = exports.hulkService = exports.AttachMetadata = exports.isTypedMetadata = exports.isSpecifiedMetadata = void 0;
const metadata_1 = require("./metadata");
const enum_1 = require("./enum");
const parameter_1 = require("../parameter");
const middleware_1 = require("../middleware");
const router_1 = require("../router");
const utils_1 = require("../utils");
const Koa = require("koa");
const compose = require("koa-compose");
const merge = require("lodash.merge");
const klawSync = require("klaw-sync");
const path = require("path");
/**
 * check the original key if a metadata is sepecified.
 *
 * Requires three parameters:
 * - `keys` - sepecified metadata keys
 * - `metadataKey` - key associated with the metadata
 *
 */
function isSpecifiedMetadata(keys, metadataKey) {
    return keys.includes(metadataKey);
}
exports.isSpecifiedMetadata = isSpecifiedMetadata;
/**
 * check and reveal the original key if a metadata is typed.
 *
 * Requires three parameters:
 * - `type` - metadata type
 * - `metadataKey` - key associated with the metadata
 * - `reveal` - `optional` - if `true` and right type passed, the original key associated with the metadata will be returned
 *
 */
function isTypedMetadata(type, metadataKey, reveal) {
    const gotcha = metadataKey.startsWith?.(type);
    if (!reveal) {
        return gotcha;
    }
    return gotcha
        ? metadataKey.replace(type, '')
        : undefined;
}
exports.isTypedMetadata = isTypedMetadata;
/**
 * 为Hulk装饰器装饰的类或类中的元素添加元数据的方法（Reflect.defineMetadata的封装，添加了对Hulk特殊类型元数据的额外处理）
 *
 * 使用方式:
 * ```typescript
 * AttachMetadata(
 *   key,
 *   value,
 * )
 *
 * or
 *
 * AttachMetadata(
 *   key,
 *   value,
 *   type,
 * )
 * ```
 *
 */
function AttachMetadata(metadataKey, metadataValue, type) {
    return (this?.SetMetadata || metadata_1.SetMetadata)(`${type || ''}${metadataKey}`, metadataValue);
}
exports.AttachMetadata = AttachMetadata;
class HulkService {
    port = 3000;
    globalPrefix = '/';
    debug = Boolean(process.env.DEBUG);
    targetMap = new Map();
    middlewareMap = new Map();
    routeMap = new Map();
    providerMap = new Map();
    defaultRouterConfig = {
        ignoreTrailingSlash: true,
        defaultRoute: (req, res) => {
            res.statusCode = 404;
            res.end(`Path ${req.url} Not Found`);
        },
    };
    log(...args) {
        if (this.debug) {
            // eslint-disable-next-line no-console
            console.log(...args);
        }
    }
    declareConstructorHandler(target, protoConstructorMap) {
        const metadataMap = new Map();
        protoConstructorMap
            ?.forEach((value, key) => {
            if (isTypedMetadata(enum_1.MetadataType.PROTO, key)) {
                metadataMap.set(key, value);
            }
        });
        protoConstructorMap
            ?.forEach((value, key) => {
            if (!isTypedMetadata(enum_1.MetadataType.PROTO, key)) {
                if (isTypedMetadata(enum_1.MetadataType.DESIGN, key)) {
                    const protoKey = key.replace(enum_1.MetadataType.DESIGN, enum_1.MetadataType.PROTO);
                    const existingProtoValue = metadataMap.get(protoKey);
                    if (existingProtoValue && key === `${enum_1.MetadataType.DESIGN}paramtypes`) {
                        const v = [...existingProtoValue, ...value];
                        metadataMap.set(protoKey, v);
                    }
                    else {
                        metadataMap.set(protoKey, value);
                    }
                    return;
                }
                metadataMap.set(key, value);
            }
        });
        Reflect
            .getOwnMetadataKeys(target)
            .forEach(key => metadataMap.set(key, Reflect.getOwnMetadata(key, target)));
        return metadataMap;
    }
    declareOwnPropertiesHandler(target, constructorMap, protoPropertiesMap) {
        function isRouteOptionsMedatata(key) {
            return isTypedMetadata(enum_1.MetadataType.ROUTE_ACTIVE, key)
                || isTypedMetadata(enum_1.MetadataType.ROUTE_CONSTRAINT, key)
                || isTypedMetadata(enum_1.MetadataType.ROUTE_STORE, key);
        }
        const ownPropertiesMap = new Map(protoPropertiesMap).set('constructor', constructorMap);
        Reflect.ownKeys(target.prototype)
            .filter(name => name !== 'constructor')
            .forEach(name => {
            const metadataMap = new Map();
            Reflect.getOwnMetadataKeys(target.prototype, name)
                .forEach(key => {
                const value = Reflect.getOwnMetadata(key, target.prototype, name);
                if (isRouteOptionsMedatata(key)) {
                    metadataMap.set(key, { value, on: 'property' });
                    return;
                }
                metadataMap.set(key, value);
            });
            const propertyDescriptorValue = Reflect.getOwnPropertyDescriptor(target.prototype, name)?.value;
            if (propertyDescriptorValue) {
                Reflect.getOwnMetadataKeys(propertyDescriptorValue)
                    .forEach(key => {
                    const value = Reflect.getOwnMetadata(key, propertyDescriptorValue);
                    if (isRouteOptionsMedatata(key)) {
                        metadataMap.set(key, { value, on: 'property' });
                        return;
                    }
                    metadataMap.set(key, value);
                });
            }
            // metadata `design:*`, `proto:*`, `REQUEST_SCOPED_PROPERTY`, `REQUEST_SCOPED_PROXY` are distinguished, according to it's scope.
            constructorMap
                ?.forEach((value, key) => {
                if (!isTypedMetadata(enum_1.MetadataType.DESIGN, key)
                    && !isTypedMetadata(enum_1.MetadataType.PROTO, key)
                    && !isSpecifiedMetadata([enum_1.MetadataKey.REQUEST_SCOPED_PROPERTY, enum_1.MetadataKey.REQUEST_SCOPED_PROXY], key)) {
                    if (isRouteOptionsMedatata(key)) {
                        metadataMap.set(key, { value, on: 'class' });
                        return;
                    }
                    metadataMap.set(key, value);
                }
            });
            ownPropertiesMap.set(name, metadataMap);
        });
        return ownPropertiesMap;
    }
    declare(target) {
        const proto = Reflect.getPrototypeOf(target);
        const protoPropertiesMap = proto && this.targetMap.get(proto);
        const constructorMap = this.declareConstructorHandler(target, protoPropertiesMap?.get('constructor'));
        const ownPropertiesMap = this.declareOwnPropertiesHandler(target, constructorMap, protoPropertiesMap);
        return ownPropertiesMap;
    }
    inject(target, rawArgs = []) {
        const protoProviders = this.targetMap
            .get(target)
            ?.get('constructor')
            ?.get(`${enum_1.MetadataType.PROTO}paramtypes`) || [];
        const providers = this.targetMap
            .get(target)
            ?.get('constructor')
            ?.get(`${enum_1.MetadataType.DESIGN}paramtypes`) || [];
        const protoProperties = [];
        const asyncProperties = [];
        let rawArgsIndex = 0;
        protoProviders
            ?.forEach((provider, i) => {
            if ((0, utils_1.isClass)(provider)) {
                if (!this.providerMap.has(provider)) {
                    this.prepare(provider);
                }
                const asyncProxy = Reflect.getOwnMetadata(enum_1.MetadataKey.REQUEST_SCOPED_PROXY, provider);
                if (asyncProxy) {
                    this.log('[hulk constructor] async proxy detected:', provider);
                    Reflect.set(asyncProperties, i, asyncProxy);
                }
                else {
                    Reflect.set(protoProperties, i, this.providerMap.get(provider));
                }
            }
        });
        const args = providers?.length
            ? providers
                .map((provider, i) => {
                if ((0, utils_1.isClass)(provider)) {
                    if (!this.providerMap.has(provider)) {
                        this.prepare(provider);
                    }
                    const asyncProxy = Reflect.getOwnMetadata(enum_1.MetadataKey.REQUEST_SCOPED_PROXY, provider);
                    if (asyncProxy) {
                        this.log('[hulk constructor] async proxy detected:', provider);
                        Reflect.set(asyncProperties, i + protoProviders.length, asyncProxy);
                        return asyncProxy();
                    }
                    return this.providerMap.get(provider);
                }
                if (rawArgsIndex < rawArgs.length) {
                    try {
                        return Reflect.get(rawArgs, rawArgsIndex);
                    }
                    finally {
                        rawArgsIndex += 1;
                    }
                }
                return undefined;
            })
                .concat(rawArgs.slice(rawArgsIndex, rawArgs.length))
            : rawArgs;
        return {
            protoProperties,
            asyncProperties,
            args,
        };
    }
    construct(target, ...rawArgs) {
        this.log('[hulk constructor] constructing:', target);
        const { [enum_1.AsyncProperty.CONTEXT]: asyncContext, [enum_1.AsyncProperty.STORE]: asyncStore, } = this.targetMap
            .get(target)
            ?.get('constructor')
            ?.get(enum_1.MetadataKey.REQUEST_SCOPED_PROPERTY) || {};
        const injection = this.inject(target, rawArgs);
        const instance = Reflect.construct(target, injection.args);
        if (injection.asyncProperties.length) {
            if (asyncContext) {
                this.log('[hulk constructor] AsyncContext detected:', asyncContext);
            }
            if (asyncStore) {
                this.log('[hulk constructor] AsyncStore detected:', asyncStore);
            }
            const properties = Reflect.ownKeys(instance);
            const asyncProperties = [];
            const asyncProxies = {};
            injection
                .asyncProperties
                .forEach((v, i) => {
                const asyncProperty = Reflect.get(properties, i);
                asyncProperties.push(asyncProperty);
                Reflect.set(asyncProxies, asyncProperty, v);
            });
            Reflect
                .defineMetadata(enum_1.MetadataKey.REQUEST_SCOPED_PROXY, (ctx) => {
                const asyncArgsInstances = {};
                return new Proxy({}, {
                    get(_, p) {
                        if (asyncProperties.includes(p)) {
                            let asyncInstance = Reflect.get(asyncArgsInstances, p);
                            if (asyncInstance) {
                                return asyncInstance;
                            }
                            asyncInstance = Reflect.get(asyncProxies, p)(ctx);
                            Reflect.set(asyncArgsInstances, p, asyncInstance);
                            return asyncInstance;
                        }
                        if (asyncContext !== undefined && asyncContext.has(p)) {
                            return ctx;
                        }
                        if (asyncStore !== undefined && asyncStore.has(p)) {
                            return ctx.state.store;
                        }
                        return Reflect.get(instance, p);
                    },
                    set(_, p, v) {
                        return Reflect.set(instance, p, v);
                    },
                });
            }, target);
        }
        else if (asyncContext || asyncStore) {
            if (asyncContext) {
                this.log('[hulk constructor] AsyncContext detected:', asyncContext);
            }
            if (asyncStore) {
                this.log('[hulk constructor] AsyncStore detected:', asyncStore);
            }
            Reflect
                .defineMetadata(enum_1.MetadataKey.REQUEST_SCOPED_PROXY, (ctx) => new Proxy({}, {
                get(_, p) {
                    if (asyncContext !== undefined && asyncContext.has(p)) {
                        return ctx;
                    }
                    if (asyncStore !== undefined && asyncStore.has(p)) {
                        return ctx.state.store;
                    }
                    return Reflect.get(instance, p);
                },
                set(_, p, v) {
                    return Reflect.set(instance, p, v);
                },
            }), target);
        }
        this.providerMap.set(target, instance);
        return instance;
    }
    prepare(target) {
        const targetMetadata = this.declare(target);
        const middlewareMetadata = middleware_1.middlewareMetadataService.declareMiddlewareHandler(target, targetMetadata, this.middlewareMap);
        const routeMetadata = router_1.routeMetadataService.declareRouteHandler(target, targetMetadata);
        this.targetMap.set(target, targetMetadata);
        if (middlewareMetadata) {
            this.middlewareMap.set(target, middlewareMetadata);
        }
        if (routeMetadata?.length) {
            this.routeMap.set(target, routeMetadata);
        }
        this.construct(target);
    }
    /** @ignore */
    generateHulkDecorator() {
        const self = this;
        return function classDecorator(target) {
            self.prepare(target);
            return target;
        };
    }
    /** @ignore */
    generateAsyncPropertyDecorator(asyncProperty) {
        return function decoratorFactory({ constructor }, propertyKey) {
            const store = Reflect.getOwnMetadata(enum_1.MetadataKey.REQUEST_SCOPED_PROPERTY, constructor) || {};
            const existingPropertyKey = Reflect.get(store, asyncProperty);
            Reflect
                .set(store, asyncProperty, existingPropertyKey ? existingPropertyKey.add(propertyKey) : new Set([propertyKey]));
            Reflect
                .defineMetadata(enum_1.MetadataKey.REQUEST_SCOPED_PROPERTY, store, constructor);
        };
    }
    /**
     * 入口
     *
     * 使用方式:
     * ```typescript
     * hulkService.lookup()
     * ```
     *
     */
    lookup(rawConfig = {}) {
        const startTime = Date.now();
        const { port = 3000, globalPrefix = '/', globalMiddlewares = [], scanControllers = true, controllers = [], beforeRouting, afterRespond, bodyParserOptions, ...rest } = rawConfig;
        const router = new router_1.RouterService(merge({}, this.defaultRouterConfig, rest));
        const parseMiddleware = ({ fn, instance, asyncProxy, needParse, parameterParser, }) => (
        // eslint-disable-next-line no-nested-ternary
        asyncProxy
            ? needParse
                ? (ctx, next) => Reflect.apply(fn, asyncProxy(ctx), parameterParser(ctx, next))
                : (ctx, next) => Reflect.apply(fn, asyncProxy(ctx), [ctx, next])
            : needParse
                ? (ctx, next) => Reflect.apply(fn, instance, parameterParser(ctx, next))
                : (ctx, next) => Reflect.apply(fn, instance, [ctx, next]));
        const registerRoutes = (routes) => {
            routes
                .forEach(route => {
                const routeMetadata = this.routeMap.get(route);
                if (routeMetadata?.length) {
                    const instance = this.providerMap.get(route);
                    if (instance) {
                        routeMetadata
                            .forEach(({ active, method, path: routePath, options, store, middlewares, handler, metadataMap, }) => {
                            if (active) {
                                const fn = Reflect.get(instance, handler);
                                const asyncProxy = Reflect.getOwnMetadata(enum_1.MetadataKey.REQUEST_SCOPED_PROXY, route);
                                const { needParse, parameterParser, parameterMiddlewares } = parameter_1.parameterMetadataService.declareParameterHandler(metadataMap);
                                const parsedMiddlewares = Array
                                    .from(new Set([...globalMiddlewares, ...middlewares]
                                    .reduce((a, c) => {
                                    if ((0, utils_1.isOtherThanClass)(c)) {
                                        a.push(c);
                                    }
                                    else {
                                        const middlewareMetadata = this.middlewareMap.get(c);
                                        if (middlewareMetadata !== undefined) {
                                            a.push(...middlewareMetadata.aggregated);
                                        }
                                    }
                                    return a;
                                }, [])))
                                    .reduce((a, c) => {
                                    if ((0, utils_1.isOtherThanClass)(c)) {
                                        a.push(c);
                                    }
                                    const middlewareMetadata = this.middlewareMap.get(c);
                                    const i = this.providerMap.get(c);
                                    if (middlewareMetadata !== undefined && i) {
                                        const f = Reflect.get(i, middlewareMetadata.keyword);
                                        if (f) {
                                            const { parameterMiddlewares: pm, ...r } = parameter_1.parameterMetadataService.declareParameterHandler(middlewareMetadata.metadataMap);
                                            const m = parseMiddleware({
                                                fn: f,
                                                instance: i,
                                                asyncProxy: Reflect.getOwnMetadata(enum_1.MetadataKey.REQUEST_SCOPED_PROXY, c),
                                                ...r,
                                            });
                                            parameterMiddlewares.push(...pm);
                                            a.push(m);
                                        }
                                    }
                                    return a;
                                }, []);
                                if (fn) {
                                    const combinedPath = path.join(globalPrefix, routePath);
                                    router.on(method, combinedPath.startsWith('/')
                                        ? combinedPath
                                        : `/${combinedPath}`, options, compose([
                                        ...Array.from(new Set(parameterMiddlewares)),
                                        ...parsedMiddlewares,
                                        (ctx, next) => Promise
                                            .resolve(parseMiddleware({
                                            fn, instance, asyncProxy, needParse, parameterParser,
                                        })(ctx, next))
                                            .then(res => {
                                            if (res !== undefined) {
                                                ctx.body = res;
                                            }
                                        }),
                                    ]), afterRespond, store);
                                }
                            }
                        });
                    }
                }
            });
        };
        if (bodyParserOptions) {
            parameter_1.parameterMetadataService.customizeBodyParser(bodyParserOptions);
        }
        const scannedControllers = [];
        if (scanControllers) {
            const entryfile = utils_1.callsite.retrieve().getFileName();
            if (entryfile) {
                const scanspace = [path.dirname(entryfile)];
                this.log('[hulk scanner] scanspace:', scanspace.toString());
                for (const space of scanspace) {
                    const files = klawSync(space, { nodir: true })
                        .filter(file => !/ignore|generated/.test(file.path)
                        && (path.extname(file.path) === '.js'
                            || (path.extname(file.path) === '.ts' && !file.path.endsWith('.d.ts'))));
                    for (const file of files) {
                        try {
                            this.log('[hulk scanner] scanning:', path.relative(process.cwd(), file.path));
                            // eslint-disable-next-line global-require, @typescript-eslint/no-var-requires
                            const content = require(file.path);
                            scannedControllers
                                .push(...Reflect
                                .ownKeys(content)
                                .map(k => Reflect.get(content, k)));
                        }
                        catch (e) {
                            this.log('[hulk scanner] error occurred:', e.message);
                        }
                    }
                }
            }
        }
        this.log('[hulk router] registering routes...\n');
        registerRoutes(Array
            .from(new Set(scanControllers
            ? [...scannedControllers, ...controllers]
            : controllers)));
        this.log(router.prettyPrint());
        const koa = new Koa();
        return new Promise(resolve => {
            const server = koa
                .use(router.lookup(beforeRouting))
                .listen(port, () => {
                this.log('app initialized in %s ms, now listening at http://0.0.0.0:%s', Date.now() - startTime, port);
                resolve(server);
            });
        });
    }
}
exports.hulkService = new HulkService();
/**
 * 类装饰器，用来收集和整理controller上的所有元数据，是所有其他装饰器正确生效的前置条件
 *
 * 使用方式:
 * ```typescript
 * @Hulk()// Hulk装饰器需置于所有controller装饰器的上方以保证被最后调用，这样才能收集到controller上的所有元数据
 * export default class UserController {
 *   ...
 * }
 * ```
 *
 */
function Hulk() {
    return exports.hulkService.generateHulkDecorator();
}
exports.Hulk = Hulk;
/**
 * 属性装饰器，设置Hulk装饰器装饰的类中的属性随请求创建，同时在constructor中注入ctx
 *
 * 使用方式:
 * ```typescript
 * @AsyncContext()
 * ctx!: HulkContext
 * ```
 *
 */
function AsyncContext() {
    return exports.hulkService.generateAsyncPropertyDecorator(enum_1.AsyncProperty.CONTEXT);
}
exports.AsyncContext = AsyncContext;
/**
 * 属性装饰器，设置Hulk装饰器装饰的类中的属性随请求创建，同时在constructor中注入ctx.state.store
 *
 * 使用方式:
 * ```typescript
 * @AsyncStore()
 * store!: Record<string, unknown>
 * ```
 *
 */
function AsyncStore() {
    return exports.hulkService.generateAsyncPropertyDecorator(enum_1.AsyncProperty.STORE);
}
exports.AsyncStore = AsyncStore;
