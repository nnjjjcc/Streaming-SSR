"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.organizeTransformHandler = exports.Transform = exports.validate = exports.organizeValidateHandler = exports.reflectSchema = exports.Schema = exports.S = void 0;
require("reflect-metadata");
const fluent_json_schema_1 = __importDefault(require("fluent-json-schema"));
const ajv_1 = __importDefault(require("ajv"));
const utils_1 = require("../../utils");
const JSON_SCHEMA = Symbol('json-schema');
const JSON_SCHEMA_FRAGMENT = Symbol('json-schema-fragment');
const JSON_SCHEMA_VALIDATE_HANDLER = Symbol('json-schema-validate-handler');
const TRANSFORM = Symbol('transform');
class SchemaService {
    isObjectSchema = (schema) => !!schema.prop;
    refIndex = 0;
    refClassMap = new WeakMap();
    refClassKeyword = '$refClass';
    ajv = new ajv_1.default({ allErrors: true, useDefaults: true }).addKeyword(this.refClassKeyword);
    recursivelyGatherRefClasses(schema) {
        let refClasses = [];
        Object.entries(schema)
            .forEach(([k, v]) => {
            if (k === this.refClassKeyword) {
                refClasses.push(v);
                return;
            }
            if (typeof (v) === 'object') {
                refClasses = refClasses.concat(this.recursivelyGatherRefClasses(v));
            }
        });
        return refClasses;
    }
    recursivelyGatherDefinitions(rootDefinitions) {
        let refDefinitions = [];
        Object.entries(rootDefinitions)
            .forEach(([ref, { definitions, ...refDefinition }]) => {
            refDefinitions.push({ ref, refDefinition });
            if (definitions) {
                refDefinitions = refDefinitions.concat(this.recursivelyGatherDefinitions(definitions));
            }
        });
        return refDefinitions;
    }
    refClass(target) {
        const existingRefClass = this.refClassMap.get(target);
        if (existingRefClass) {
            return fluent_json_schema_1.default.object()
                .ref(`#/definitions/${existingRefClass.ref}`)
                .raw({ [this.refClassKeyword]: existingRefClass });
        }
        // eslint-disable-next-line no-plusplus
        const refClass = { ref: `${this.refIndex++}`, refClass: target };
        this.refClassMap.set(target, refClass);
        return fluent_json_schema_1.default.object()
            .ref(`#/definitions/${refClass.ref}`)
            .raw({ [this.refClassKeyword]: refClass });
    }
    organizeSchema(target) {
        let targetSchema = Reflect.getOwnMetadata(JSON_SCHEMA, target);
        if (!targetSchema) {
            const propertySchemas = Reflect.getOwnMetadata(JSON_SCHEMA_FRAGMENT, target.prototype);
            const classSchema = Reflect.getOwnMetadata(JSON_SCHEMA_FRAGMENT, target);
            let targetRefClasses = [];
            if (classSchema) {
                targetSchema = this.isObjectSchema(classSchema)
                    ? classSchema
                    : fluent_json_schema_1.default.object().raw(classSchema.valueOf());
                Reflect.deleteMetadata(JSON_SCHEMA_FRAGMENT, target);
            }
            else {
                targetSchema = fluent_json_schema_1.default.object();
            }
            if (propertySchemas) {
                Object.entries(propertySchemas)
                    .forEach(([property, propertySchema]) => {
                    const refClasses = this.recursivelyGatherRefClasses(propertySchema.valueOf({ isRoot: false }));
                    targetRefClasses = targetRefClasses.concat(refClasses);
                    targetSchema = targetSchema.prop(property, propertySchema);
                });
                Reflect.deleteMetadata(JSON_SCHEMA_FRAGMENT, target.prototype);
            }
            const { refs, deduplicatedTargetRefClasses, } = targetRefClasses.reduce((a, c) => {
                if (a.refs.includes(c.ref)) {
                    return a;
                }
                return {
                    refs: [...a.refs, c.ref],
                    deduplicatedTargetRefClasses: [...a.deduplicatedTargetRefClasses, c],
                };
            }, {
                refs: [],
                deduplicatedTargetRefClasses: [],
            });
            deduplicatedTargetRefClasses
                .forEach(targetRefClass => {
                const { ref, refClass } = targetRefClass;
                const selfReferring = refClass === target;
                const schema = selfReferring
                    ? targetSchema.valueOf()
                    : this.organizeSchema(refClass).valueOf();
                const { definitions, ...restSchema } = schema;
                targetSchema = targetSchema.definition(ref, fluent_json_schema_1.default.raw(restSchema));
                if (!selfReferring && definitions) {
                    const innerDefinitions = this.recursivelyGatherDefinitions(definitions);
                    innerDefinitions
                        .forEach(({ ref: innerRef, refDefinition }) => {
                        if (!refs.includes(innerRef)) {
                            refs.push(innerRef);
                            targetSchema = targetSchema.definition(innerRef, fluent_json_schema_1.default.raw(refDefinition));
                        }
                    });
                }
            });
            const validateHandler = this.ajv.compile(targetSchema.valueOf());
            Reflect.defineMetadata(JSON_SCHEMA, targetSchema, target);
            Reflect.defineMetadata(JSON_SCHEMA_VALIDATE_HANDLER, validateHandler, target);
        }
        return targetSchema;
    }
}
const schemaService = new SchemaService();
/**
 * **fluent-api S:**
 * - 快速上手: https://www.fastify.io/docs/latest/Fluent-Schema/
 * - 原始项目: https://github.com/fastify/fluent-json-schema
 * - 快速理解 json schema: https://json-schema.org/understanding-json-schema/index.html
 *
 * **额外api:**
 * - `refClass`: 在json schema中，当需要依赖现有schema时需要通过definition + ref的方式实现，整体代码较为繁琐，所以新增了refClass的api，只需要 **refClass(ReferredClass)** 即可直接继承校验规则
 *
 * 使用方式:
 * ```typescript
 * class User {
 *   @Schema(S.number().required())// number and required
 *   property0: number
 *
 *   @Schema(S.anyOf([S.number(), S.boolean()]))// number or boolean, not required
 *   property1?: number | boolean
 * }
 *
 * @Schema(S.title('title for UserGroup'))// comments
 * class UserGroup {
 *   @Schema(S.array().items(S.refClass(User)).required())
 *   users: User[]
 * }
 *
 * @Hulk()
 * @provide()
 * @controller('/user')
 * export default class UserController {
 *   @post('/group_add')
 *   async groupAdd(
 *     ctx,
 *     @Body() body: UserGroup,// body会接受UserGroup上定义的json schema校验
 *     next,
 *   ): IResult<any> {
 *     ...
 *   }
 * }
 * ```
 *
 */
const S = {
    ...fluent_json_schema_1.default,
    refClass: schemaService.refClass.bind(schemaService),
};
exports.S = S;
function Schema(schema) {
    // eslint-disable-next-line consistent-return
    function decoratorFactory(target, propertyKey) {
        if (propertyKey === undefined) {
            Reflect.defineMetadata(JSON_SCHEMA_FRAGMENT, schema, target);
            return target;
        }
        if (typeof (propertyKey) === 'string') {
            const propertySchema = Reflect.getOwnMetadata(JSON_SCHEMA_FRAGMENT, target) || {};
            propertySchema[propertyKey] = schema;
            Reflect.defineMetadata(JSON_SCHEMA_FRAGMENT, propertySchema, target);
        }
    }
    return decoratorFactory;
}
exports.Schema = Schema;
/**
 * 获取指定class上定义的json schema
 *
 * 使用方式:
 * ```typescript
 * class User {
 *   @Schema(S.number().required())// number and required
 *   property0: number
 *
 *   @Schema(S.anyOf([S.number(), S.boolean()]))// number or boolean, not required
 *   property1?: number | boolean
 * }
 *
 * @Schema(S.title('title for UserGroup'))// comments
 * class UserGroup {
 *   @Schema(S.array().items(S.refClass(User)).required())
 *   users: User[]
 * }
 *
 * reflectSchema(UserGroup)
 *
 * // {
 * //   $schema: 'http://json-schema.org/draft-07/schema#',
 * //   definitions:
 * //   {
 * //     '0': {
 * //       type: 'object',
 * //       properties: {
 * //         property0: {
 * //           type: 'number',
 * //         },
 * //         property1: {
 * //           anyOf: [
 * //             { type: 'number' },
 * //             { type: 'boolean' },
 * //           ],
 * //         },
 * //       },
 * //       required: ['property0'],
 * //     },
 * //   },
 * //   type: 'object',
 * //   title: 'title for UserGroup',
 * //   properties: {
 * //     users: {
 * //       type: 'array',
 * //       items: {
 * //         type: 'object',
 * //         $ref: '#/definitions/0',
 * //       },
 * //     },
 * //   },
 * //   required: ['users'],
 * // }
 * ```
 *
 */
function reflectSchema(target) {
    return schemaService.organizeSchema(target).valueOf();
}
exports.reflectSchema = reflectSchema;
/** @ignore */
function organizeValidateHandler(target) {
    schemaService.organizeSchema(target);
    return Reflect.getOwnMetadata(JSON_SCHEMA_VALIDATE_HANDLER, target);
}
exports.organizeValidateHandler = organizeValidateHandler;
/**
 * 传入定义过schema的class和json手动校验
 *
 * 使用方式:
 * ```typescript
 * class C {
 *   @Schema(S.string().required())
 *   string: string
 * }
 *
 * class B {
 *   @Schema(S.string())
 *   string?: string
 *
 *   @Schema(S.refClass(C))
 *   refC?: C
 * }
 *
 * class A {
 *   // 一个最大长度为3，元素为整数的数组，默认[0]
 *   @Schema(S.array().maxItems(3).items(S.integer()).default([0]))
 *   array?: number[] = [0]
 *
 *   @Schema(S.allOf([S.refClass(A), S.refClass(B)]))
 *   allOfAandB?: A & B
 *
 *   @Schema(S.anyOf([S.refClass(A), S.refClass(B), S.refClass(C)]))
 *   anyOfAorB?: A | B | C
 * }
 *
 * const a = { allOfAandB: { refC: { } } }
 *
 * validate(A, a)
 *
 * // {
 * //   valid: false,
 * //   errors: [
 * //     {
 * //       keyword: 'required',
 * //       dataPath: '/allOfAandB/refC',
 * //       schemaPath: '#/definitions/0/required',
 * //       params: { missingProperty: 'string' },
 * //       message: "should have required property 'string'",
 * //     },
 * //   ],
 * // }
 *
 * const b = { allOfAandB: { refC: { string: 'string' } } }
 *
 * validate(A, b)
 *
 * // {
 * //   valid: true,
 * //   errors: null,
 * // }
 * //
 * // 若定义了default，参数对应的成员若未传值则会被写入default的值
 * // b => {
 * //   allOfAandB: { refC: { string: 'string' }, array: [0] },
 * //   array: [0],
 * // }
 * ```
 *
 */
function validate(target, subTarget) {
    if ((0, utils_1.isClass)(target)) {
        const validateHandler = organizeValidateHandler(target);
        const valid = validateHandler(subTarget);
        const { errors } = validateHandler;
        return {
            valid,
            errors,
        };
    }
    return {
        valid: true,
    };
}
exports.validate = validate;
/**
 * 属性装饰器，用来进行入参转换
 *
 * 使用方式:
 * ```typescript
 * class QueryDto {
 *   @Transform(v => Number(v))
 *   stringnumber: number
 *   ...
 * }
 * ```
 *
 */
function Transform(transform) {
    return function decoratorFactory({ constructor }, propertyKey) {
        const store = Reflect.getOwnMetadata(TRANSFORM, constructor) || {};
        Reflect.set(store, propertyKey, transform);
        Reflect.defineMetadata(TRANSFORM, store, constructor);
    };
}
exports.Transform = Transform;
/** @ignore */
function organizeTransformHandler(target) {
    return Object.entries(Reflect.getOwnMetadata(TRANSFORM, target) || {});
}
exports.organizeTransformHandler = organizeTransformHandler;
