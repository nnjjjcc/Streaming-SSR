import { JoinedParameterParser } from './interface';
import Koa = require('koa');
import bodyParser = require('koa-bodyparser');
declare class ParameterMetadataService {
    private rawBodyParser;
    private bodyParser;
    declareParameterHandler(methodMetadataMap: Map<any, any>): {
        needParse: boolean;
        parameterParser: JoinedParameterParser;
        parameterMiddlewares: Koa.Middleware[];
    };
    customizeBodyParser(options: bodyParser.Options): void;
}
declare const parameterMetadataService: ParameterMetadataService;
/**
 * 参数装饰器，用来提取请求的request（即ctx.req）
 *
 * 可与其他参数装饰器一起使用，或重复使用，原始的ctx、next也依然可以按序拿到（可以任意插入在被装饰的参数前、后、或中间）
 *
 * 使用方式:
 * ```typescript
 * async method(
 *   @Req() req: IncomingMessage,
 *   ctx,
 *   next,
 * ): any {
 *   ...
 * }
 * ```
 *
 */
declare function Req(): ParameterDecorator;
/**
 * 参数装饰器，用来提取请求的headers
 *
 * 可与其他参数装饰器一起使用，或重复使用，原始的ctx、next也依然可以按序拿到（可以任意插入在被装饰的参数前、后、或中间）
 *
 * 使用方式:
 * ```typescript
 * async method(
 *   @Req() req: IncomingMessage,
 *   ctx,
 *   next,
 *   @Headers() headers: IncomingHttpHeaders,
 *   @Headers('content-type') contentType: string,
 * ): any {
 *   ...
 * }
 * ```
 *
 */
declare function Headers(k?: string): ParameterDecorator;
/**
 * 参数装饰器，用来提取请求的params
 *
 * 可与其他参数装饰器一起使用，或重复使用，原始的ctx、next也依然可以按序拿到（可以任意插入在被装饰的参数前、后、或中间）
 *
 * 使用方式:
 * ```typescript
 * async method(
 *   @Req() req: IncomingMessage,
 *   @Params() params: ParamsType,
 *   ctx,
 *   next
 * ): any {
 *   ...
 * }
 * ```
 *
 */
declare function Params(): ParameterDecorator;
/**
 * 参数装饰器，用来提取请求的query
 *
 * 可与其他参数装饰器一起使用，或重复使用，原始的ctx、next也依然可以按序拿到（可以任意插入在被装饰的参数前、后、或中间）
 *
 * 使用方式:
 * ```typescript
 * async method(
 *   @Req() req: IncomingMessage,
 *   @Query() query: QueryType,
 *   ctx,
 *   next
 * ): any {
 *   ...
 * }
 * ```
 *
 */
declare function Query(): ParameterDecorator;
/**
 * 参数装饰器，用来提取请求的body
 *
 * 可与其他参数装饰器一起使用，或重复使用，原始的ctx、next也依然可以按序拿到（可以任意插入在被装饰的参数前、后、或中间）
 *
 * 使用方式:
 * ```typescript
 * async method(
 *   ctx,
 *   @Body() body: BodyType,
 *   next,
 * ): any {
 *   ...
 * }
 * ```
 *
 */
declare function Body(): ParameterDecorator;
/**
 * 参数装饰器，用来提取请求的state
 *
 * 可与其他参数装饰器一起使用，或重复使用，原始的ctx、next也依然可以按序拿到（可以任意插入在被装饰的参数前、后、或中间）
 *
 * 使用方式:
 * ```typescript
 * async method(
 *   ctx,
 *   @State() state: string,
 *   next,
 * ): any {
 *   ...
 * }
 * ```
 *
 */
declare function State(): ParameterDecorator;
/**
 * 参数装饰器，用来提取请求的host
 *
 * 可与其他参数装饰器一起使用，或重复使用，原始的ctx、next也依然可以按序拿到（可以任意插入在被装饰的参数前、后、或中间）
 *
 * 使用方式:
 * ```typescript
 * async method(
 *   ctx,
 *   @Host() host: string,
 *   next,
 * ): any {
 *   ...
 * }
 * ```
 *
 */
declare function Host(): ParameterDecorator;
/**
 * 参数装饰器，用来提取请求的version
 *
 * 可与其他参数装饰器一起使用，或重复使用，原始的ctx、next也依然可以按序拿到（可以任意插入在被装饰的参数前、后、或中间）
 *
 * 使用方式:
 * ```typescript
 * async method(
 *   ctx,
 *   @Version() version: string,
 *   next,
 * ): any {
 *   ...
 * }
 * ```
 *
 */
declare function Version(): ParameterDecorator;
/**
 * 参数装饰器，用来提取请求的store
 *
 * 可与其他参数装饰器一起使用，或重复使用，原始的ctx、next也依然可以按序拿到（可以任意插入在被装饰的参数前、后、或中间）
 *
 * 使用方式:
 * ```typescript
 * async method(
 *   ctx,
 *   @Store() store: StoreType,
 *   next,
 * ): any {
 *   ...
 * }
 * ```
 *
 */
declare function Store(): ParameterDecorator;
/**
 * 参数装饰器，用来提取请求的response（即ctx.res）
 *
 * 可与其他参数装饰器一起使用，或重复使用，原始的ctx、next也依然可以按序拿到（可以任意插入在被装饰的参数前、后、或中间）
 *
 * 使用方式:
 * ```typescript
 * async method(
 *   ctx,
 *   next,
 *   @Res() res: ServerResponse,
 * ): any {
 *   ...
 * }
 * ```
 *
 */
declare function Res(): ParameterDecorator;
/**
 * 参数装饰器，用来提取next
 *
 * 可与其他参数装饰器一起使用，或重复使用，原始的ctx也依然可以按序拿到（可以任意插入在被装饰的参数前、后、或中间）
 *
 * 使用方式:
 * ```typescript
 * async method(
 *   ctx,
 *   @Next() next: Koa.Next,
 * ): any {
 *   ...
 * }
 * ```
 *
 */
declare function Next(): ParameterDecorator;
export { parameterMetadataService, Req, Headers, Params, Query, Body, State, Host, Version, Store, Res, Next, };
