"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Next = exports.Res = exports.Store = exports.Version = exports.Host = exports.State = exports.Body = exports.Query = exports.Params = exports.Headers = exports.Req = exports.parameterMetadataService = void 0;
/* eslint-disable import/order */
const di_1 = require("../di");
const utils_1 = require("../utils");
const schema_1 = require("./schema");
const enum_1 = require("./enum");
const bodyParser = require("koa-bodyparser");
// import querystring = require('querystring')
class ParameterMetadataService {
    rawBodyParser = bodyParser({ enableTypes: ['json', 'form', 'text'] });
    // private queryParser = async (
    //   ctx: Koa.Context,
    //   next: Koa.Next,
    // ): Promise<void> => {
    //   ctx.state.query = querystring.parse(ctx.querystring)
    //   await next()
    // }
    bodyParser = async (ctx, next) => {
        await this.rawBodyParser(ctx, async () => {
            ctx.state.body = ctx.request.body;
        });
        await next();
    };
    declareParameterHandler(methodMetadataMap) {
        let parameterTypes = [];
        const parameterMetadata = [];
        const parameterMiddlewares = [];
        methodMetadataMap
            .forEach((v, k) => {
            if (k === 'design:paramtypes') {
                parameterTypes = v;
                return;
            }
            const parameterMetadataType = (0, di_1.isTypedMetadata)(di_1.MetadataType.PARAMETER, k, true);
            if (parameterMetadataType) {
                v
                    .forEach((adapter, i) => {
                    if (adapter) {
                        parameterMetadata[i] = adapter;
                    }
                });
                // if (parameterMetadataType === ParameterMetadataKey.QUERY) {
                //   parameterMiddlewares.push(this.queryParser)
                // }
                if (parameterMetadataType === enum_1.ParameterMetadataKey.BODY) {
                    parameterMiddlewares.push(this.bodyParser);
                }
            }
        });
        let rawIndex = 0;
        const parameterParsers = [];
        for (let i = 0; i < parameterMetadata.length; i++) {
            const parameterType = Reflect.get(parameterTypes, i);
            const parameterParser = Reflect.get(parameterMetadata, i);
            if (parameterParser) {
                let parser = parameterParser;
                if (parameterType) {
                    const transform = (0, schema_1.organizeTransformHandler)(parameterType);
                    if (transform.length) {
                        parser = (ctx, next) => transform
                            .reduce((a, [k, v]) => {
                            Reflect.set(a, k, v(Reflect.get(a, k)));
                            return a;
                        }, parameterParser(ctx, next));
                    }
                }
                if ((0, utils_1.isClass)(parameterType)) {
                    const parameterName = parameterType.name;
                    const validateHandler = (0, schema_1.organizeValidateHandler)(parameterType);
                    parameterParsers
                        .push((ctx, next) => {
                        const parameter = parser(ctx, next);
                        const valid = validateHandler(parameter);
                        if (valid) {
                            return parameter;
                        }
                        throw utils_1.HttpError
                            .create('BadRequest')
                            .setMsg(`Validate ${parameterName} Failed`);
                    });
                }
                else {
                    parameterParsers
                        .push((ctx, next) => parser(ctx, next));
                }
            }
            else {
                const index = rawIndex;
                parameterParsers.push((...raw) => Reflect.get(raw, index));
                rawIndex += 1;
            }
        }
        const needParse = parameterParsers.length > 0;
        switch (rawIndex) {
            case 0:
                return {
                    needParse,
                    parameterParser: (ctx, next) => ([
                        ...parameterParsers.map(parser => parser(ctx, next)),
                        ctx,
                        next,
                    ]),
                    parameterMiddlewares,
                };
            case 1:
                return {
                    needParse,
                    parameterParser: (ctx, next) => ([
                        ...parameterParsers.map(parser => parser(ctx, next)),
                        next,
                    ]),
                    parameterMiddlewares,
                };
            default:
                return {
                    needParse,
                    parameterParser: (ctx, next) => parameterParsers.map(parser => parser(ctx, next)),
                    parameterMiddlewares,
                };
        }
    }
    customizeBodyParser(options) {
        this.rawBodyParser = bodyParser(options);
    }
}
const parameterMetadataService = new ParameterMetadataService();
exports.parameterMetadataService = parameterMetadataService;
/**
 * 参数装饰器，用来提取请求的request（即ctx.req）
 *
 * 可与其他参数装饰器一起使用，或重复使用，原始的ctx、next也依然可以按序拿到（可以任意插入在被装饰的参数前、后、或中间）
 *
 * 使用方式:
 * ```typescript
 * async method(
 *   @Req() req: IncomingMessage,
 *   ctx,
 *   next,
 * ): any {
 *   ...
 * }
 * ```
 *
 */
function Req() {
    return (0, di_1.AttachMetadata)(enum_1.ParameterMetadataKey.REQ, (ctx) => ctx.req, di_1.MetadataType.PARAMETER);
}
exports.Req = Req;
/**
 * 参数装饰器，用来提取请求的headers
 *
 * 可与其他参数装饰器一起使用，或重复使用，原始的ctx、next也依然可以按序拿到（可以任意插入在被装饰的参数前、后、或中间）
 *
 * 使用方式:
 * ```typescript
 * async method(
 *   @Req() req: IncomingMessage,
 *   ctx,
 *   next,
 *   @Headers() headers: IncomingHttpHeaders,
 *   @Headers('content-type') contentType: string,
 * ): any {
 *   ...
 * }
 * ```
 *
 */
function Headers(k) {
    return (0, di_1.AttachMetadata)(enum_1.ParameterMetadataKey.HEADERS, (ctx) => (k
        ? ctx.req.headers[k]
        : ctx.req.headers), di_1.MetadataType.PARAMETER);
}
exports.Headers = Headers;
/**
 * 参数装饰器，用来提取请求的params
 *
 * 可与其他参数装饰器一起使用，或重复使用，原始的ctx、next也依然可以按序拿到（可以任意插入在被装饰的参数前、后、或中间）
 *
 * 使用方式:
 * ```typescript
 * async method(
 *   @Req() req: IncomingMessage,
 *   @Params() params: ParamsType,
 *   ctx,
 *   next
 * ): any {
 *   ...
 * }
 * ```
 *
 */
function Params() {
    return (0, di_1.AttachMetadata)(enum_1.ParameterMetadataKey.PARAMS, (ctx) => ctx.state.params, di_1.MetadataType.PARAMETER);
}
exports.Params = Params;
/**
 * 参数装饰器，用来提取请求的query
 *
 * 可与其他参数装饰器一起使用，或重复使用，原始的ctx、next也依然可以按序拿到（可以任意插入在被装饰的参数前、后、或中间）
 *
 * 使用方式:
 * ```typescript
 * async method(
 *   @Req() req: IncomingMessage,
 *   @Query() query: QueryType,
 *   ctx,
 *   next
 * ): any {
 *   ...
 * }
 * ```
 *
 */
function Query() {
    return (0, di_1.AttachMetadata)(enum_1.ParameterMetadataKey.QUERY, (ctx) => ctx.state.query, di_1.MetadataType.PARAMETER);
}
exports.Query = Query;
/**
 * 参数装饰器，用来提取请求的body
 *
 * 可与其他参数装饰器一起使用，或重复使用，原始的ctx、next也依然可以按序拿到（可以任意插入在被装饰的参数前、后、或中间）
 *
 * 使用方式:
 * ```typescript
 * async method(
 *   ctx,
 *   @Body() body: BodyType,
 *   next,
 * ): any {
 *   ...
 * }
 * ```
 *
 */
function Body() {
    return (0, di_1.AttachMetadata)(enum_1.ParameterMetadataKey.BODY, (ctx) => ctx.state.body, di_1.MetadataType.PARAMETER);
}
exports.Body = Body;
/**
 * 参数装饰器，用来提取请求的state
 *
 * 可与其他参数装饰器一起使用，或重复使用，原始的ctx、next也依然可以按序拿到（可以任意插入在被装饰的参数前、后、或中间）
 *
 * 使用方式:
 * ```typescript
 * async method(
 *   ctx,
 *   @State() state: string,
 *   next,
 * ): any {
 *   ...
 * }
 * ```
 *
 */
function State() {
    return (0, di_1.AttachMetadata)(enum_1.ParameterMetadataKey.STATE, (ctx) => ctx.state, di_1.MetadataType.PARAMETER);
}
exports.State = State;
/**
 * 参数装饰器，用来提取请求的host
 *
 * 可与其他参数装饰器一起使用，或重复使用，原始的ctx、next也依然可以按序拿到（可以任意插入在被装饰的参数前、后、或中间）
 *
 * 使用方式:
 * ```typescript
 * async method(
 *   ctx,
 *   @Host() host: string,
 *   next,
 * ): any {
 *   ...
 * }
 * ```
 *
 */
function Host() {
    return (0, di_1.AttachMetadata)(enum_1.ParameterMetadataKey.HOST, (ctx) => ctx.req.headers.host, di_1.MetadataType.PARAMETER);
}
exports.Host = Host;
/**
 * 参数装饰器，用来提取请求的version
 *
 * 可与其他参数装饰器一起使用，或重复使用，原始的ctx、next也依然可以按序拿到（可以任意插入在被装饰的参数前、后、或中间）
 *
 * 使用方式:
 * ```typescript
 * async method(
 *   ctx,
 *   @Version() version: string,
 *   next,
 * ): any {
 *   ...
 * }
 * ```
 *
 */
function Version() {
    return (0, di_1.AttachMetadata)(enum_1.ParameterMetadataKey.VERSION, (ctx) => ctx.req.headers['accept-version'], di_1.MetadataType.PARAMETER);
}
exports.Version = Version;
/**
 * 参数装饰器，用来提取请求的store
 *
 * 可与其他参数装饰器一起使用，或重复使用，原始的ctx、next也依然可以按序拿到（可以任意插入在被装饰的参数前、后、或中间）
 *
 * 使用方式:
 * ```typescript
 * async method(
 *   ctx,
 *   @Store() store: StoreType,
 *   next,
 * ): any {
 *   ...
 * }
 * ```
 *
 */
function Store() {
    return (0, di_1.AttachMetadata)(enum_1.ParameterMetadataKey.STORE, (ctx) => ctx.state.store, di_1.MetadataType.PARAMETER);
}
exports.Store = Store;
/**
 * 参数装饰器，用来提取请求的response（即ctx.res）
 *
 * 可与其他参数装饰器一起使用，或重复使用，原始的ctx、next也依然可以按序拿到（可以任意插入在被装饰的参数前、后、或中间）
 *
 * 使用方式:
 * ```typescript
 * async method(
 *   ctx,
 *   next,
 *   @Res() res: ServerResponse,
 * ): any {
 *   ...
 * }
 * ```
 *
 */
function Res() {
    return (0, di_1.AttachMetadata)(enum_1.ParameterMetadataKey.RES, (ctx) => ctx.res, di_1.MetadataType.PARAMETER);
}
exports.Res = Res;
/**
 * 参数装饰器，用来提取next
 *
 * 可与其他参数装饰器一起使用，或重复使用，原始的ctx也依然可以按序拿到（可以任意插入在被装饰的参数前、后、或中间）
 *
 * 使用方式:
 * ```typescript
 * async method(
 *   ctx,
 *   @Next() next: Koa.Next,
 * ): any {
 *   ...
 * }
 * ```
 *
 */
function Next() {
    return (0, di_1.AttachMetadata)(enum_1.ParameterMetadataKey.NEXT, (ctx, next) => next, di_1.MetadataType.PARAMETER);
}
exports.Next = Next;
