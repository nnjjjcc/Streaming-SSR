"use strict";
// @generated by protoc-gen-es v1.2.0 with parameter "target=ts,import_extension=none"
// @generated from file envoy/api/v2/core/base.proto (package envoy.api.v2.core, syntax proto3)
/* eslint-disable */
// @ts-nocheck
Object.defineProperty(exports, "__esModule", { value: true });
exports.ControlPlane = exports.RuntimeFractionalPercent = exports.TransportSocket = exports.AsyncDataSource = exports.RemoteDataSource = exports.RetryPolicy = exports.DataSource = exports.HeaderMap = exports.HeaderValueOption = exports.HeaderValue = exports.RuntimeFeatureFlag = exports.RuntimeDouble = exports.RuntimeUInt32 = exports.Metadata = exports.Node = exports.Extension = exports.BuildVersion = exports.Locality = exports.TrafficDirection = exports.RequestMethod = exports.RoutingPriority = void 0;
const protobuf_1 = require("@bufbuild/protobuf");
const semantic_version_pb_1 = require("../../../type/semantic_version_pb");
const struct_pb_1 = require("../../../../google/protobuf/struct_pb");
const address_pb_1 = require("./address_pb");
const wrappers_pb_1 = require("../../../../google/protobuf/wrappers_pb");
const backoff_pb_1 = require("./backoff_pb");
const http_uri_pb_1 = require("./http_uri_pb");
const any_pb_1 = require("../../../../google/protobuf/any_pb");
const percent_pb_1 = require("../../../type/percent_pb");
/**
 * Envoy supports :ref:`upstream priority routing
 * <arch_overview_http_routing_priority>` both at the route and the virtual
 * cluster level. The current priority implementation uses different connection
 * pool and circuit breaking settings for each priority level. This means that
 * even for HTTP/2 requests, two physical connections will be used to an
 * upstream host. In the future Envoy will likely support true HTTP/2 priority
 * over a single upstream connection.
 *
 * @generated from enum envoy.api.v2.core.RoutingPriority
 */
var RoutingPriority;
(function (RoutingPriority) {
    /**
     * @generated from enum value: DEFAULT = 0;
     */
    RoutingPriority[RoutingPriority["DEFAULT"] = 0] = "DEFAULT";
    /**
     * @generated from enum value: HIGH = 1;
     */
    RoutingPriority[RoutingPriority["HIGH"] = 1] = "HIGH";
})(RoutingPriority || (exports.RoutingPriority = RoutingPriority = {}));
// Retrieve enum metadata with: proto3.getEnumType(RoutingPriority)
protobuf_1.proto3.util.setEnumType(RoutingPriority, "envoy.api.v2.core.RoutingPriority", [
    { no: 0, name: "DEFAULT" },
    { no: 1, name: "HIGH" },
]);
/**
 * HTTP request method.
 *
 * @generated from enum envoy.api.v2.core.RequestMethod
 */
var RequestMethod;
(function (RequestMethod) {
    /**
     * @generated from enum value: METHOD_UNSPECIFIED = 0;
     */
    RequestMethod[RequestMethod["METHOD_UNSPECIFIED"] = 0] = "METHOD_UNSPECIFIED";
    /**
     * @generated from enum value: GET = 1;
     */
    RequestMethod[RequestMethod["GET"] = 1] = "GET";
    /**
     * @generated from enum value: HEAD = 2;
     */
    RequestMethod[RequestMethod["HEAD"] = 2] = "HEAD";
    /**
     * @generated from enum value: POST = 3;
     */
    RequestMethod[RequestMethod["POST"] = 3] = "POST";
    /**
     * @generated from enum value: PUT = 4;
     */
    RequestMethod[RequestMethod["PUT"] = 4] = "PUT";
    /**
     * @generated from enum value: DELETE = 5;
     */
    RequestMethod[RequestMethod["DELETE"] = 5] = "DELETE";
    /**
     * @generated from enum value: CONNECT = 6;
     */
    RequestMethod[RequestMethod["CONNECT"] = 6] = "CONNECT";
    /**
     * @generated from enum value: OPTIONS = 7;
     */
    RequestMethod[RequestMethod["OPTIONS"] = 7] = "OPTIONS";
    /**
     * @generated from enum value: TRACE = 8;
     */
    RequestMethod[RequestMethod["TRACE"] = 8] = "TRACE";
    /**
     * @generated from enum value: PATCH = 9;
     */
    RequestMethod[RequestMethod["PATCH"] = 9] = "PATCH";
})(RequestMethod || (exports.RequestMethod = RequestMethod = {}));
// Retrieve enum metadata with: proto3.getEnumType(RequestMethod)
protobuf_1.proto3.util.setEnumType(RequestMethod, "envoy.api.v2.core.RequestMethod", [
    { no: 0, name: "METHOD_UNSPECIFIED" },
    { no: 1, name: "GET" },
    { no: 2, name: "HEAD" },
    { no: 3, name: "POST" },
    { no: 4, name: "PUT" },
    { no: 5, name: "DELETE" },
    { no: 6, name: "CONNECT" },
    { no: 7, name: "OPTIONS" },
    { no: 8, name: "TRACE" },
    { no: 9, name: "PATCH" },
]);
/**
 * Identifies the direction of the traffic relative to the local Envoy.
 *
 * @generated from enum envoy.api.v2.core.TrafficDirection
 */
var TrafficDirection;
(function (TrafficDirection) {
    /**
     * Default option is unspecified.
     *
     * @generated from enum value: UNSPECIFIED = 0;
     */
    TrafficDirection[TrafficDirection["UNSPECIFIED"] = 0] = "UNSPECIFIED";
    /**
     * The transport is used for incoming traffic.
     *
     * @generated from enum value: INBOUND = 1;
     */
    TrafficDirection[TrafficDirection["INBOUND"] = 1] = "INBOUND";
    /**
     * The transport is used for outgoing traffic.
     *
     * @generated from enum value: OUTBOUND = 2;
     */
    TrafficDirection[TrafficDirection["OUTBOUND"] = 2] = "OUTBOUND";
})(TrafficDirection || (exports.TrafficDirection = TrafficDirection = {}));
// Retrieve enum metadata with: proto3.getEnumType(TrafficDirection)
protobuf_1.proto3.util.setEnumType(TrafficDirection, "envoy.api.v2.core.TrafficDirection", [
    { no: 0, name: "UNSPECIFIED" },
    { no: 1, name: "INBOUND" },
    { no: 2, name: "OUTBOUND" },
]);
/**
 * Identifies location of where either Envoy runs or where upstream hosts run.
 *
 * @generated from message envoy.api.v2.core.Locality
 */
class Locality extends protobuf_1.Message {
    /**
     * Region this :ref:`zone <envoy_api_field_core.Locality.zone>` belongs to.
     *
     * @generated from field: string region = 1;
     */
    region = "";
    /**
     * Defines the local service zone where Envoy is running. Though optional, it
     * should be set if discovery service routing is used and the discovery
     * service exposes :ref:`zone data <envoy_api_field_endpoint.LocalityLbEndpoints.locality>`,
     * either in this message or via :option:`--service-zone`. The meaning of zone
     * is context dependent, e.g. `Availability Zone (AZ)
     * <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html>`_
     * on AWS, `Zone <https://cloud.google.com/compute/docs/regions-zones/>`_ on
     * GCP, etc.
     *
     * @generated from field: string zone = 2;
     */
    zone = "";
    /**
     * When used for locality of upstream hosts, this field further splits zone
     * into smaller chunks of sub-zones so they can be load balanced
     * independently.
     *
     * @generated from field: string sub_zone = 3;
     */
    subZone = "";
    constructor(data) {
        super();
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static runtime = protobuf_1.proto3;
    static typeName = "envoy.api.v2.core.Locality";
    static fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "region", kind: "scalar", T: 9 /* ScalarType.STRING */ },
        { no: 2, name: "zone", kind: "scalar", T: 9 /* ScalarType.STRING */ },
        { no: 3, name: "sub_zone", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    ]);
    static fromBinary(bytes, options) {
        return new Locality().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Locality().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Locality().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(Locality, a, b);
    }
}
exports.Locality = Locality;
/**
 * BuildVersion combines SemVer version of extension with free-form build information
 * (i.e. 'alpha', 'private-build') as a set of strings.
 *
 * @generated from message envoy.api.v2.core.BuildVersion
 */
class BuildVersion extends protobuf_1.Message {
    /**
     * SemVer version of extension.
     *
     * @generated from field: envoy.type.SemanticVersion version = 1;
     */
    version;
    /**
     * Free-form build information.
     * Envoy defines several well known keys in the source/common/version/version.h file
     *
     * @generated from field: google.protobuf.Struct metadata = 2;
     */
    metadata;
    constructor(data) {
        super();
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static runtime = protobuf_1.proto3;
    static typeName = "envoy.api.v2.core.BuildVersion";
    static fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "version", kind: "message", T: semantic_version_pb_1.SemanticVersion },
        { no: 2, name: "metadata", kind: "message", T: struct_pb_1.Struct },
    ]);
    static fromBinary(bytes, options) {
        return new BuildVersion().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new BuildVersion().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new BuildVersion().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(BuildVersion, a, b);
    }
}
exports.BuildVersion = BuildVersion;
/**
 * Version and identification for an Envoy extension.
 * [#next-free-field: 6]
 *
 * @generated from message envoy.api.v2.core.Extension
 */
class Extension extends protobuf_1.Message {
    /**
     * This is the name of the Envoy filter as specified in the Envoy
     * configuration, e.g. envoy.filters.http.router, com.acme.widget.
     *
     * @generated from field: string name = 1;
     */
    name = "";
    /**
     * Category of the extension.
     * Extension category names use reverse DNS notation. For instance "envoy.filters.listener"
     * for Envoy's built-in listener filters or "com.acme.filters.http" for HTTP filters from
     * acme.com vendor.
     * [#comment:TODO(yanavlasov): Link to the doc with existing envoy category names.]
     *
     * @generated from field: string category = 2;
     */
    category = "";
    /**
     * [#not-implemented-hide:] Type descriptor of extension configuration proto.
     * [#comment:TODO(yanavlasov): Link to the doc with existing configuration protos.]
     * [#comment:TODO(yanavlasov): Add tests when PR #9391 lands.]
     *
     * @generated from field: string type_descriptor = 3;
     */
    typeDescriptor = "";
    /**
     * The version is a property of the extension and maintained independently
     * of other extensions and the Envoy API.
     * This field is not set when extension did not provide version information.
     *
     * @generated from field: envoy.api.v2.core.BuildVersion version = 4;
     */
    version;
    /**
     * Indicates that the extension is present but was disabled via dynamic configuration.
     *
     * @generated from field: bool disabled = 5;
     */
    disabled = false;
    constructor(data) {
        super();
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static runtime = protobuf_1.proto3;
    static typeName = "envoy.api.v2.core.Extension";
    static fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
        { no: 2, name: "category", kind: "scalar", T: 9 /* ScalarType.STRING */ },
        { no: 3, name: "type_descriptor", kind: "scalar", T: 9 /* ScalarType.STRING */ },
        { no: 4, name: "version", kind: "message", T: BuildVersion },
        { no: 5, name: "disabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    ]);
    static fromBinary(bytes, options) {
        return new Extension().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Extension().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Extension().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(Extension, a, b);
    }
}
exports.Extension = Extension;
/**
 * Identifies a specific Envoy instance. The node identifier is presented to the
 * management server, which may use this identifier to distinguish per Envoy
 * configuration for serving.
 * [#next-free-field: 12]
 *
 * @generated from message envoy.api.v2.core.Node
 */
class Node extends protobuf_1.Message {
    /**
     * An opaque node identifier for the Envoy node. This also provides the local
     * service node name. It should be set if any of the following features are
     * used: :ref:`statsd <arch_overview_statistics>`, :ref:`CDS
     * <config_cluster_manager_cds>`, and :ref:`HTTP tracing
     * <arch_overview_tracing>`, either in this message or via
     * :option:`--service-node`.
     *
     * @generated from field: string id = 1;
     */
    id = "";
    /**
     * Defines the local service cluster name where Envoy is running. Though
     * optional, it should be set if any of the following features are used:
     * :ref:`statsd <arch_overview_statistics>`, :ref:`health check cluster
     * verification
     * <envoy_api_field_core.HealthCheck.HttpHealthCheck.service_name_matcher>`,
     * :ref:`runtime override directory <envoy_api_msg_config.bootstrap.v2.Runtime>`,
     * :ref:`user agent addition
     * <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.add_user_agent>`,
     * :ref:`HTTP global rate limiting <config_http_filters_rate_limit>`,
     * :ref:`CDS <config_cluster_manager_cds>`, and :ref:`HTTP tracing
     * <arch_overview_tracing>`, either in this message or via
     * :option:`--service-cluster`.
     *
     * @generated from field: string cluster = 2;
     */
    cluster = "";
    /**
     * Opaque metadata extending the node identifier. Envoy will pass this
     * directly to the management server.
     *
     * @generated from field: google.protobuf.Struct metadata = 3;
     */
    metadata;
    /**
     * Locality specifying where the Envoy instance is running.
     *
     * @generated from field: envoy.api.v2.core.Locality locality = 4;
     */
    locality;
    /**
     * This is motivated by informing a management server during canary which
     * version of Envoy is being tested in a heterogeneous fleet. This will be set
     * by Envoy in management server RPCs.
     * This field is deprecated in favor of the user_agent_name and user_agent_version values.
     *
     * @generated from field: string build_version = 5 [deprecated = true];
     * @deprecated
     */
    buildVersion = "";
    /**
     * Free-form string that identifies the entity requesting config.
     * E.g. "envoy" or "grpc"
     *
     * @generated from field: string user_agent_name = 6;
     */
    userAgentName = "";
    /**
     * @generated from oneof envoy.api.v2.core.Node.user_agent_version_type
     */
    userAgentVersionType = { case: undefined };
    /**
     * List of extensions and their versions supported by the node.
     *
     * @generated from field: repeated envoy.api.v2.core.Extension extensions = 9;
     */
    extensions = [];
    /**
     * Client feature support list. These are well known features described
     * in the Envoy API repository for a given major version of an API. Client features
     * use reverse DNS naming scheme, for example `com.acme.feature`.
     * See :ref:`the list of features <client_features>` that xDS client may
     * support.
     *
     * @generated from field: repeated string client_features = 10;
     */
    clientFeatures = [];
    /**
     * Known listening ports on the node as a generic hint to the management server
     * for filtering :ref:`listeners <config_listeners>` to be returned. For example,
     * if there is a listener bound to port 80, the list can optionally contain the
     * SocketAddress `(0.0.0.0,80)`. The field is optional and just a hint.
     *
     * @generated from field: repeated envoy.api.v2.core.Address listening_addresses = 11;
     */
    listeningAddresses = [];
    constructor(data) {
        super();
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static runtime = protobuf_1.proto3;
    static typeName = "envoy.api.v2.core.Node";
    static fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
        { no: 2, name: "cluster", kind: "scalar", T: 9 /* ScalarType.STRING */ },
        { no: 3, name: "metadata", kind: "message", T: struct_pb_1.Struct },
        { no: 4, name: "locality", kind: "message", T: Locality },
        { no: 5, name: "build_version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
        { no: 6, name: "user_agent_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
        { no: 7, name: "user_agent_version", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "user_agent_version_type" },
        { no: 8, name: "user_agent_build_version", kind: "message", T: BuildVersion, oneof: "user_agent_version_type" },
        { no: 9, name: "extensions", kind: "message", T: Extension, repeated: true },
        { no: 10, name: "client_features", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
        { no: 11, name: "listening_addresses", kind: "message", T: address_pb_1.Address, repeated: true },
    ]);
    static fromBinary(bytes, options) {
        return new Node().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Node().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Node().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(Node, a, b);
    }
}
exports.Node = Node;
/**
 * Metadata provides additional inputs to filters based on matched listeners,
 * filter chains, routes and endpoints. It is structured as a map, usually from
 * filter name (in reverse DNS format) to metadata specific to the filter. Metadata
 * key-values for a filter are merged as connection and request handling occurs,
 * with later values for the same key overriding earlier values.
 *
 * An example use of metadata is providing additional values to
 * http_connection_manager in the envoy.http_connection_manager.access_log
 * namespace.
 *
 * Another example use of metadata is to per service config info in cluster metadata, which may get
 * consumed by multiple filters.
 *
 * For load balancing, Metadata provides a means to subset cluster endpoints.
 * Endpoints have a Metadata object associated and routes contain a Metadata
 * object to match against. There are some well defined metadata used today for
 * this purpose:
 *
 * * ``{"envoy.lb": {"canary": <bool> }}`` This indicates the canary status of an
 *   endpoint and is also used during header processing
 *   (x-envoy-upstream-canary) and for stats purposes.
 * [#next-major-version: move to type/metadata/v2]
 *
 * @generated from message envoy.api.v2.core.Metadata
 */
class Metadata extends protobuf_1.Message {
    /**
     * Key is the reverse DNS filter name, e.g. com.acme.widget. The envoy.*
     * namespace is reserved for Envoy's built-in filters.
     *
     * @generated from field: map<string, google.protobuf.Struct> filter_metadata = 1;
     */
    filterMetadata = {};
    constructor(data) {
        super();
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static runtime = protobuf_1.proto3;
    static typeName = "envoy.api.v2.core.Metadata";
    static fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "filter_metadata", kind: "map", K: 9 /* ScalarType.STRING */, V: { kind: "message", T: struct_pb_1.Struct } },
    ]);
    static fromBinary(bytes, options) {
        return new Metadata().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Metadata().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Metadata().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(Metadata, a, b);
    }
}
exports.Metadata = Metadata;
/**
 * Runtime derived uint32 with a default when not specified.
 *
 * @generated from message envoy.api.v2.core.RuntimeUInt32
 */
class RuntimeUInt32 extends protobuf_1.Message {
    /**
     * Default value if runtime value is not available.
     *
     * @generated from field: uint32 default_value = 2;
     */
    defaultValue = 0;
    /**
     * Runtime key to get value for comparison. This value is used if defined.
     *
     * @generated from field: string runtime_key = 3;
     */
    runtimeKey = "";
    constructor(data) {
        super();
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static runtime = protobuf_1.proto3;
    static typeName = "envoy.api.v2.core.RuntimeUInt32";
    static fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 2, name: "default_value", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
        { no: 3, name: "runtime_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    ]);
    static fromBinary(bytes, options) {
        return new RuntimeUInt32().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new RuntimeUInt32().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new RuntimeUInt32().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(RuntimeUInt32, a, b);
    }
}
exports.RuntimeUInt32 = RuntimeUInt32;
/**
 * Runtime derived double with a default when not specified.
 *
 * @generated from message envoy.api.v2.core.RuntimeDouble
 */
class RuntimeDouble extends protobuf_1.Message {
    /**
     * Default value if runtime value is not available.
     *
     * @generated from field: double default_value = 1;
     */
    defaultValue = 0;
    /**
     * Runtime key to get value for comparison. This value is used if defined.
     *
     * @generated from field: string runtime_key = 2;
     */
    runtimeKey = "";
    constructor(data) {
        super();
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static runtime = protobuf_1.proto3;
    static typeName = "envoy.api.v2.core.RuntimeDouble";
    static fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "default_value", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
        { no: 2, name: "runtime_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    ]);
    static fromBinary(bytes, options) {
        return new RuntimeDouble().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new RuntimeDouble().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new RuntimeDouble().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(RuntimeDouble, a, b);
    }
}
exports.RuntimeDouble = RuntimeDouble;
/**
 * Runtime derived bool with a default when not specified.
 *
 * @generated from message envoy.api.v2.core.RuntimeFeatureFlag
 */
class RuntimeFeatureFlag extends protobuf_1.Message {
    /**
     * Default value if runtime value is not available.
     *
     * @generated from field: google.protobuf.BoolValue default_value = 1;
     */
    defaultValue;
    /**
     * Runtime key to get value for comparison. This value is used if defined. The boolean value must
     * be represented via its
     * `canonical JSON encoding <https://developers.google.com/protocol-buffers/docs/proto3#json>`_.
     *
     * @generated from field: string runtime_key = 2;
     */
    runtimeKey = "";
    constructor(data) {
        super();
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static runtime = protobuf_1.proto3;
    static typeName = "envoy.api.v2.core.RuntimeFeatureFlag";
    static fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "default_value", kind: "message", T: wrappers_pb_1.BoolValue },
        { no: 2, name: "runtime_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    ]);
    static fromBinary(bytes, options) {
        return new RuntimeFeatureFlag().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new RuntimeFeatureFlag().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new RuntimeFeatureFlag().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(RuntimeFeatureFlag, a, b);
    }
}
exports.RuntimeFeatureFlag = RuntimeFeatureFlag;
/**
 * Header name/value pair.
 *
 * @generated from message envoy.api.v2.core.HeaderValue
 */
class HeaderValue extends protobuf_1.Message {
    /**
     * Header name.
     *
     * @generated from field: string key = 1;
     */
    key = "";
    /**
     * Header value.
     *
     * The same :ref:`format specifier <config_access_log_format>` as used for
     * :ref:`HTTP access logging <config_access_log>` applies here, however
     * unknown header values are replaced with the empty string instead of `-`.
     *
     * @generated from field: string value = 2;
     */
    value = "";
    constructor(data) {
        super();
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static runtime = protobuf_1.proto3;
    static typeName = "envoy.api.v2.core.HeaderValue";
    static fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
        { no: 2, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    ]);
    static fromBinary(bytes, options) {
        return new HeaderValue().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new HeaderValue().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new HeaderValue().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(HeaderValue, a, b);
    }
}
exports.HeaderValue = HeaderValue;
/**
 * Header name/value pair plus option to control append behavior.
 *
 * @generated from message envoy.api.v2.core.HeaderValueOption
 */
class HeaderValueOption extends protobuf_1.Message {
    /**
     * Header name/value pair that this option applies to.
     *
     * @generated from field: envoy.api.v2.core.HeaderValue header = 1;
     */
    header;
    /**
     * Should the value be appended? If true (default), the value is appended to
     * existing values.
     *
     * @generated from field: google.protobuf.BoolValue append = 2;
     */
    append;
    constructor(data) {
        super();
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static runtime = protobuf_1.proto3;
    static typeName = "envoy.api.v2.core.HeaderValueOption";
    static fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "header", kind: "message", T: HeaderValue },
        { no: 2, name: "append", kind: "message", T: wrappers_pb_1.BoolValue },
    ]);
    static fromBinary(bytes, options) {
        return new HeaderValueOption().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new HeaderValueOption().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new HeaderValueOption().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(HeaderValueOption, a, b);
    }
}
exports.HeaderValueOption = HeaderValueOption;
/**
 * Wrapper for a set of headers.
 *
 * @generated from message envoy.api.v2.core.HeaderMap
 */
class HeaderMap extends protobuf_1.Message {
    /**
     * @generated from field: repeated envoy.api.v2.core.HeaderValue headers = 1;
     */
    headers = [];
    constructor(data) {
        super();
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static runtime = protobuf_1.proto3;
    static typeName = "envoy.api.v2.core.HeaderMap";
    static fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "headers", kind: "message", T: HeaderValue, repeated: true },
    ]);
    static fromBinary(bytes, options) {
        return new HeaderMap().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new HeaderMap().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new HeaderMap().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(HeaderMap, a, b);
    }
}
exports.HeaderMap = HeaderMap;
/**
 * Data source consisting of either a file or an inline value.
 *
 * @generated from message envoy.api.v2.core.DataSource
 */
class DataSource extends protobuf_1.Message {
    /**
     * @generated from oneof envoy.api.v2.core.DataSource.specifier
     */
    specifier = { case: undefined };
    constructor(data) {
        super();
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static runtime = protobuf_1.proto3;
    static typeName = "envoy.api.v2.core.DataSource";
    static fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "filename", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "specifier" },
        { no: 2, name: "inline_bytes", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "specifier" },
        { no: 3, name: "inline_string", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "specifier" },
    ]);
    static fromBinary(bytes, options) {
        return new DataSource().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new DataSource().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new DataSource().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(DataSource, a, b);
    }
}
exports.DataSource = DataSource;
/**
 * The message specifies the retry policy of remote data source when fetching fails.
 *
 * @generated from message envoy.api.v2.core.RetryPolicy
 */
class RetryPolicy extends protobuf_1.Message {
    /**
     * Specifies parameters that control :ref:`retry backoff strategy <envoy_api_msg_core.BackoffStrategy>`.
     * This parameter is optional, in which case the default base interval is 1000 milliseconds. The
     * default maximum interval is 10 times the base interval.
     *
     * @generated from field: envoy.api.v2.core.BackoffStrategy retry_back_off = 1;
     */
    retryBackOff;
    /**
     * Specifies the allowed number of retries. This parameter is optional and
     * defaults to 1.
     *
     * @generated from field: google.protobuf.UInt32Value num_retries = 2;
     */
    numRetries;
    constructor(data) {
        super();
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static runtime = protobuf_1.proto3;
    static typeName = "envoy.api.v2.core.RetryPolicy";
    static fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "retry_back_off", kind: "message", T: backoff_pb_1.BackoffStrategy },
        { no: 2, name: "num_retries", kind: "message", T: wrappers_pb_1.UInt32Value },
    ]);
    static fromBinary(bytes, options) {
        return new RetryPolicy().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new RetryPolicy().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new RetryPolicy().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(RetryPolicy, a, b);
    }
}
exports.RetryPolicy = RetryPolicy;
/**
 * The message specifies how to fetch data from remote and how to verify it.
 *
 * @generated from message envoy.api.v2.core.RemoteDataSource
 */
class RemoteDataSource extends protobuf_1.Message {
    /**
     * The HTTP URI to fetch the remote data.
     *
     * @generated from field: envoy.api.v2.core.HttpUri http_uri = 1;
     */
    httpUri;
    /**
     * SHA256 string for verifying data.
     *
     * @generated from field: string sha256 = 2;
     */
    sha256 = "";
    /**
     * Retry policy for fetching remote data.
     *
     * @generated from field: envoy.api.v2.core.RetryPolicy retry_policy = 3;
     */
    retryPolicy;
    constructor(data) {
        super();
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static runtime = protobuf_1.proto3;
    static typeName = "envoy.api.v2.core.RemoteDataSource";
    static fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "http_uri", kind: "message", T: http_uri_pb_1.HttpUri },
        { no: 2, name: "sha256", kind: "scalar", T: 9 /* ScalarType.STRING */ },
        { no: 3, name: "retry_policy", kind: "message", T: RetryPolicy },
    ]);
    static fromBinary(bytes, options) {
        return new RemoteDataSource().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new RemoteDataSource().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new RemoteDataSource().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(RemoteDataSource, a, b);
    }
}
exports.RemoteDataSource = RemoteDataSource;
/**
 * Async data source which support async data fetch.
 *
 * @generated from message envoy.api.v2.core.AsyncDataSource
 */
class AsyncDataSource extends protobuf_1.Message {
    /**
     * @generated from oneof envoy.api.v2.core.AsyncDataSource.specifier
     */
    specifier = { case: undefined };
    constructor(data) {
        super();
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static runtime = protobuf_1.proto3;
    static typeName = "envoy.api.v2.core.AsyncDataSource";
    static fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "local", kind: "message", T: DataSource, oneof: "specifier" },
        { no: 2, name: "remote", kind: "message", T: RemoteDataSource, oneof: "specifier" },
    ]);
    static fromBinary(bytes, options) {
        return new AsyncDataSource().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new AsyncDataSource().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new AsyncDataSource().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(AsyncDataSource, a, b);
    }
}
exports.AsyncDataSource = AsyncDataSource;
/**
 * Configuration for transport socket in :ref:`listeners <config_listeners>` and
 * :ref:`clusters <envoy_api_msg_Cluster>`. If the configuration is
 * empty, a default transport socket implementation and configuration will be
 * chosen based on the platform and existence of tls_context.
 *
 * @generated from message envoy.api.v2.core.TransportSocket
 */
class TransportSocket extends protobuf_1.Message {
    /**
     * The name of the transport socket to instantiate. The name must match a supported transport
     * socket implementation.
     *
     * @generated from field: string name = 1;
     */
    name = "";
    /**
     * Implementation specific configuration which depends on the implementation being instantiated.
     * See the supported transport socket implementations for further documentation.
     *
     * @generated from oneof envoy.api.v2.core.TransportSocket.config_type
     */
    configType = { case: undefined };
    constructor(data) {
        super();
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static runtime = protobuf_1.proto3;
    static typeName = "envoy.api.v2.core.TransportSocket";
    static fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
        { no: 2, name: "config", kind: "message", T: struct_pb_1.Struct, oneof: "config_type" },
        { no: 3, name: "typed_config", kind: "message", T: any_pb_1.Any, oneof: "config_type" },
    ]);
    static fromBinary(bytes, options) {
        return new TransportSocket().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new TransportSocket().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new TransportSocket().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(TransportSocket, a, b);
    }
}
exports.TransportSocket = TransportSocket;
/**
 * Runtime derived FractionalPercent with defaults for when the numerator or denominator is not
 * specified via a runtime key.
 *
 * .. note::
 *
 *   Parsing of the runtime key's data is implemented such that it may be represented as a
 *   :ref:`FractionalPercent <envoy_api_msg_type.FractionalPercent>` proto represented as JSON/YAML
 *   and may also be represented as an integer with the assumption that the value is an integral
 *   percentage out of 100. For instance, a runtime key lookup returning the value "42" would parse
 *   as a `FractionalPercent` whose numerator is 42 and denominator is HUNDRED.
 *
 * @generated from message envoy.api.v2.core.RuntimeFractionalPercent
 */
class RuntimeFractionalPercent extends protobuf_1.Message {
    /**
     * Default value if the runtime value's for the numerator/denominator keys are not available.
     *
     * @generated from field: envoy.type.FractionalPercent default_value = 1;
     */
    defaultValue;
    /**
     * Runtime key for a YAML representation of a FractionalPercent.
     *
     * @generated from field: string runtime_key = 2;
     */
    runtimeKey = "";
    constructor(data) {
        super();
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static runtime = protobuf_1.proto3;
    static typeName = "envoy.api.v2.core.RuntimeFractionalPercent";
    static fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "default_value", kind: "message", T: percent_pb_1.FractionalPercent },
        { no: 2, name: "runtime_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    ]);
    static fromBinary(bytes, options) {
        return new RuntimeFractionalPercent().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new RuntimeFractionalPercent().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new RuntimeFractionalPercent().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(RuntimeFractionalPercent, a, b);
    }
}
exports.RuntimeFractionalPercent = RuntimeFractionalPercent;
/**
 * Identifies a specific ControlPlane instance that Envoy is connected to.
 *
 * @generated from message envoy.api.v2.core.ControlPlane
 */
class ControlPlane extends protobuf_1.Message {
    /**
     * An opaque control plane identifier that uniquely identifies an instance
     * of control plane. This can be used to identify which control plane instance,
     * the Envoy is connected to.
     *
     * @generated from field: string identifier = 1;
     */
    identifier = "";
    constructor(data) {
        super();
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static runtime = protobuf_1.proto3;
    static typeName = "envoy.api.v2.core.ControlPlane";
    static fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "identifier", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    ]);
    static fromBinary(bytes, options) {
        return new ControlPlane().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new ControlPlane().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new ControlPlane().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(ControlPlane, a, b);
    }
}
exports.ControlPlane = ControlPlane;
