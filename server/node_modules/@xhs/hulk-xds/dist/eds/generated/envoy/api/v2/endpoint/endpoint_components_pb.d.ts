import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { Address } from "../core/address_pb";
import { HealthStatus } from "../core/health_check_pb";
import { Locality, Metadata } from "../core/base_pb";
/**
 * Upstream host identifier.
 *
 * @generated from message envoy.api.v2.endpoint.Endpoint
 */
export declare class Endpoint extends Message<Endpoint> {
    /**
     * The upstream host address.
     *
     * .. attention::
     *
     *   The form of host address depends on the given cluster type. For STATIC or EDS,
     *   it is expected to be a direct IP address (or something resolvable by the
     *   specified :ref:`resolver <envoy_api_field_core.SocketAddress.resolver_name>`
     *   in the Address). For LOGICAL or STRICT DNS, it is expected to be hostname,
     *   and will be resolved via DNS.
     *
     * @generated from field: envoy.api.v2.core.Address address = 1;
     */
    address?: Address;
    /**
     * The optional health check configuration is used as configuration for the
     * health checker to contact the health checked host.
     *
     * .. attention::
     *
     *   This takes into effect only for upstream clusters with
     *   :ref:`active health checking <arch_overview_health_checking>` enabled.
     *
     * @generated from field: envoy.api.v2.endpoint.Endpoint.HealthCheckConfig health_check_config = 2;
     */
    healthCheckConfig?: Endpoint_HealthCheckConfig;
    /**
     * The hostname associated with this endpoint. This hostname is not used for routing or address
     * resolution. If provided, it will be associated with the endpoint, and can be used for features
     * that require a hostname, like
     * :ref:`auto_host_rewrite <envoy_api_field_route.RouteAction.auto_host_rewrite>`.
     *
     * @generated from field: string hostname = 3;
     */
    hostname: string;
    constructor(data?: PartialMessage<Endpoint>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "envoy.api.v2.endpoint.Endpoint";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Endpoint;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Endpoint;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Endpoint;
    static equals(a: Endpoint | PlainMessage<Endpoint> | undefined, b: Endpoint | PlainMessage<Endpoint> | undefined): boolean;
}
/**
 * The optional health check configuration.
 *
 * @generated from message envoy.api.v2.endpoint.Endpoint.HealthCheckConfig
 */
export declare class Endpoint_HealthCheckConfig extends Message<Endpoint_HealthCheckConfig> {
    /**
     * Optional alternative health check port value.
     *
     * By default the health check address port of an upstream host is the same
     * as the host's serving address port. This provides an alternative health
     * check port. Setting this with a non-zero value allows an upstream host
     * to have different health check address port.
     *
     * @generated from field: uint32 port_value = 1;
     */
    portValue: number;
    /**
     * By default, the host header for L7 health checks is controlled by cluster level configuration
     * (see: :ref:`host <envoy_api_field_core.HealthCheck.HttpHealthCheck.host>` and
     * :ref:`authority <envoy_api_field_core.HealthCheck.GrpcHealthCheck.authority>`). Setting this
     * to a non-empty value allows overriding the cluster level configuration for a specific
     * endpoint.
     *
     * @generated from field: string hostname = 2;
     */
    hostname: string;
    constructor(data?: PartialMessage<Endpoint_HealthCheckConfig>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "envoy.api.v2.endpoint.Endpoint.HealthCheckConfig";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Endpoint_HealthCheckConfig;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Endpoint_HealthCheckConfig;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Endpoint_HealthCheckConfig;
    static equals(a: Endpoint_HealthCheckConfig | PlainMessage<Endpoint_HealthCheckConfig> | undefined, b: Endpoint_HealthCheckConfig | PlainMessage<Endpoint_HealthCheckConfig> | undefined): boolean;
}
/**
 * An Endpoint that Envoy can route traffic to.
 * [#next-free-field: 6]
 *
 * @generated from message envoy.api.v2.endpoint.LbEndpoint
 */
export declare class LbEndpoint extends Message<LbEndpoint> {
    /**
     * Upstream host identifier or a named reference.
     *
     * @generated from oneof envoy.api.v2.endpoint.LbEndpoint.host_identifier
     */
    hostIdentifier: {
        /**
         * @generated from field: envoy.api.v2.endpoint.Endpoint endpoint = 1;
         */
        value: Endpoint;
        case: "endpoint";
    } | {
        /**
         * [#not-implemented-hide:]
         *
         * @generated from field: string endpoint_name = 5;
         */
        value: string;
        case: "endpointName";
    } | {
        case: undefined;
        value?: undefined;
    };
    /**
     * Optional health status when known and supplied by EDS server.
     *
     * @generated from field: envoy.api.v2.core.HealthStatus health_status = 2;
     */
    healthStatus: HealthStatus;
    /**
     * The endpoint metadata specifies values that may be used by the load
     * balancer to select endpoints in a cluster for a given request. The filter
     * name should be specified as *envoy.lb*. An example boolean key-value pair
     * is *canary*, providing the optional canary status of the upstream host.
     * This may be matched against in a route's
     * :ref:`RouteAction <envoy_api_msg_route.RouteAction>` metadata_match field
     * to subset the endpoints considered in cluster load balancing.
     *
     * @generated from field: envoy.api.v2.core.Metadata metadata = 3;
     */
    metadata?: Metadata;
    /**
     * The optional load balancing weight of the upstream host; at least 1.
     * Envoy uses the load balancing weight in some of the built in load
     * balancers. The load balancing weight for an endpoint is divided by the sum
     * of the weights of all endpoints in the endpoint's locality to produce a
     * percentage of traffic for the endpoint. This percentage is then further
     * weighted by the endpoint's locality's load balancing weight from
     * LocalityLbEndpoints. If unspecified, each host is presumed to have equal
     * weight in a locality. The sum of the weights of all endpoints in the
     * endpoint's locality must not exceed uint32_t maximal value (4294967295).
     *
     * @generated from field: google.protobuf.UInt32Value load_balancing_weight = 4;
     */
    loadBalancingWeight?: number;
    constructor(data?: PartialMessage<LbEndpoint>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "envoy.api.v2.endpoint.LbEndpoint";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LbEndpoint;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LbEndpoint;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LbEndpoint;
    static equals(a: LbEndpoint | PlainMessage<LbEndpoint> | undefined, b: LbEndpoint | PlainMessage<LbEndpoint> | undefined): boolean;
}
/**
 * A group of endpoints belonging to a Locality.
 * One can have multiple LocalityLbEndpoints for a locality, but this is
 * generally only done if the different groups need to have different load
 * balancing weights or different priorities.
 * [#next-free-field: 7]
 *
 * @generated from message envoy.api.v2.endpoint.LocalityLbEndpoints
 */
export declare class LocalityLbEndpoints extends Message<LocalityLbEndpoints> {
    /**
     * Identifies location of where the upstream hosts run.
     *
     * @generated from field: envoy.api.v2.core.Locality locality = 1;
     */
    locality?: Locality;
    /**
     * The group of endpoints belonging to the locality specified.
     *
     * @generated from field: repeated envoy.api.v2.endpoint.LbEndpoint lb_endpoints = 2;
     */
    lbEndpoints: LbEndpoint[];
    /**
     * Optional: Per priority/region/zone/sub_zone weight; at least 1. The load
     * balancing weight for a locality is divided by the sum of the weights of all
     * localities  at the same priority level to produce the effective percentage
     * of traffic for the locality. The sum of the weights of all localities at
     * the same priority level must not exceed uint32_t maximal value (4294967295).
     *
     * Locality weights are only considered when :ref:`locality weighted load
     * balancing <arch_overview_load_balancing_locality_weighted_lb>` is
     * configured. These weights are ignored otherwise. If no weights are
     * specified when locality weighted load balancing is enabled, the locality is
     * assigned no load.
     *
     * @generated from field: google.protobuf.UInt32Value load_balancing_weight = 3;
     */
    loadBalancingWeight?: number;
    /**
     * Optional: the priority for this LocalityLbEndpoints. If unspecified this will
     * default to the highest priority (0).
     *
     * Under usual circumstances, Envoy will only select endpoints for the highest
     * priority (0). In the event all endpoints for a particular priority are
     * unavailable/unhealthy, Envoy will fail over to selecting endpoints for the
     * next highest priority group.
     *
     * Priorities should range from 0 (highest) to N (lowest) without skipping.
     *
     * @generated from field: uint32 priority = 5;
     */
    priority: number;
    /**
     * Optional: Per locality proximity value which indicates how close this
     * locality is from the source locality. This value only provides ordering
     * information (lower the value, closer it is to the source locality).
     * This will be consumed by load balancing schemes that need proximity order
     * to determine where to route the requests.
     * [#not-implemented-hide:]
     *
     * @generated from field: google.protobuf.UInt32Value proximity = 6;
     */
    proximity?: number;
    constructor(data?: PartialMessage<LocalityLbEndpoints>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "envoy.api.v2.endpoint.LocalityLbEndpoints";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LocalityLbEndpoints;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LocalityLbEndpoints;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LocalityLbEndpoints;
    static equals(a: LocalityLbEndpoints | PlainMessage<LocalityLbEndpoints> | undefined, b: LocalityLbEndpoints | PlainMessage<LocalityLbEndpoints> | undefined): boolean;
}
