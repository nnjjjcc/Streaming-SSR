"use strict";
// @generated by protoc-gen-es v1.2.0 with parameter "target=ts,import_extension=none"
// @generated from file envoy/api/v2/core/health_check.proto (package envoy.api.v2.core, syntax proto3)
/* eslint-disable */
// @ts-nocheck
Object.defineProperty(exports, "__esModule", { value: true });
exports.HealthCheck_TlsOptions = exports.HealthCheck_CustomHealthCheck = exports.HealthCheck_GrpcHealthCheck = exports.HealthCheck_RedisHealthCheck = exports.HealthCheck_TcpHealthCheck = exports.HealthCheck_HttpHealthCheck = exports.HealthCheck_Payload = exports.HealthCheck = exports.HealthStatus = void 0;
const protobuf_1 = require("@bufbuild/protobuf");
const duration_pb_1 = require("../../../../google/protobuf/duration_pb");
const event_service_config_pb_1 = require("./event_service_config_pb");
const wrappers_pb_1 = require("../../../../google/protobuf/wrappers_pb");
const base_pb_1 = require("./base_pb");
const range_pb_1 = require("../../../type/range_pb");
const http_pb_1 = require("../../../type/http_pb");
const string_pb_1 = require("../../../type/matcher/string_pb");
const struct_pb_1 = require("../../../../google/protobuf/struct_pb");
const any_pb_1 = require("../../../../google/protobuf/any_pb");
/**
 * Endpoint health status.
 *
 * @generated from enum envoy.api.v2.core.HealthStatus
 */
var HealthStatus;
(function (HealthStatus) {
    /**
     * The health status is not known. This is interpreted by Envoy as *HEALTHY*.
     *
     * @generated from enum value: UNKNOWN = 0;
     */
    HealthStatus[HealthStatus["UNKNOWN"] = 0] = "UNKNOWN";
    /**
     * Healthy.
     *
     * @generated from enum value: HEALTHY = 1;
     */
    HealthStatus[HealthStatus["HEALTHY"] = 1] = "HEALTHY";
    /**
     * Unhealthy.
     *
     * @generated from enum value: UNHEALTHY = 2;
     */
    HealthStatus[HealthStatus["UNHEALTHY"] = 2] = "UNHEALTHY";
    /**
     * Connection draining in progress. E.g.,
     * `<https://aws.amazon.com/blogs/aws/elb-connection-draining-remove-instances-from-service-with-care/>`_
     * or
     * `<https://cloud.google.com/compute/docs/load-balancing/enabling-connection-draining>`_.
     * This is interpreted by Envoy as *UNHEALTHY*.
     *
     * @generated from enum value: DRAINING = 3;
     */
    HealthStatus[HealthStatus["DRAINING"] = 3] = "DRAINING";
    /**
     * Health check timed out. This is part of HDS and is interpreted by Envoy as
     * *UNHEALTHY*.
     *
     * @generated from enum value: TIMEOUT = 4;
     */
    HealthStatus[HealthStatus["TIMEOUT"] = 4] = "TIMEOUT";
    /**
     * Degraded.
     *
     * @generated from enum value: DEGRADED = 5;
     */
    HealthStatus[HealthStatus["DEGRADED"] = 5] = "DEGRADED";
})(HealthStatus || (exports.HealthStatus = HealthStatus = {}));
// Retrieve enum metadata with: proto3.getEnumType(HealthStatus)
protobuf_1.proto3.util.setEnumType(HealthStatus, "envoy.api.v2.core.HealthStatus", [
    { no: 0, name: "UNKNOWN" },
    { no: 1, name: "HEALTHY" },
    { no: 2, name: "UNHEALTHY" },
    { no: 3, name: "DRAINING" },
    { no: 4, name: "TIMEOUT" },
    { no: 5, name: "DEGRADED" },
]);
/**
 * [#next-free-field: 23]
 *
 * @generated from message envoy.api.v2.core.HealthCheck
 */
class HealthCheck extends protobuf_1.Message {
    /**
     * The time to wait for a health check response. If the timeout is reached the
     * health check attempt will be considered a failure.
     *
     * @generated from field: google.protobuf.Duration timeout = 1;
     */
    timeout;
    /**
     * The interval between health checks.
     *
     * @generated from field: google.protobuf.Duration interval = 2;
     */
    interval;
    /**
     * An optional jitter amount in milliseconds. If specified, Envoy will start health
     * checking after for a random time in ms between 0 and initial_jitter. This only
     * applies to the first health check.
     *
     * @generated from field: google.protobuf.Duration initial_jitter = 20;
     */
    initialJitter;
    /**
     * An optional jitter amount in milliseconds. If specified, during every
     * interval Envoy will add interval_jitter to the wait time.
     *
     * @generated from field: google.protobuf.Duration interval_jitter = 3;
     */
    intervalJitter;
    /**
     * An optional jitter amount as a percentage of interval_ms. If specified,
     * during every interval Envoy will add interval_ms *
     * interval_jitter_percent / 100 to the wait time.
     *
     * If interval_jitter_ms and interval_jitter_percent are both set, both of
     * them will be used to increase the wait time.
     *
     * @generated from field: uint32 interval_jitter_percent = 18;
     */
    intervalJitterPercent = 0;
    /**
     * The number of unhealthy health checks required before a host is marked
     * unhealthy. Note that for *http* health checking if a host responds with 503
     * this threshold is ignored and the host is considered unhealthy immediately.
     *
     * @generated from field: google.protobuf.UInt32Value unhealthy_threshold = 4;
     */
    unhealthyThreshold;
    /**
     * The number of healthy health checks required before a host is marked
     * healthy. Note that during startup, only a single successful health check is
     * required to mark a host healthy.
     *
     * @generated from field: google.protobuf.UInt32Value healthy_threshold = 5;
     */
    healthyThreshold;
    /**
     * [#not-implemented-hide:] Non-serving port for health checking.
     *
     * @generated from field: google.protobuf.UInt32Value alt_port = 6;
     */
    altPort;
    /**
     * Reuse health check connection between health checks. Default is true.
     *
     * @generated from field: google.protobuf.BoolValue reuse_connection = 7;
     */
    reuseConnection;
    /**
     * @generated from oneof envoy.api.v2.core.HealthCheck.health_checker
     */
    healthChecker = { case: undefined };
    /**
     * The "no traffic interval" is a special health check interval that is used when a cluster has
     * never had traffic routed to it. This lower interval allows cluster information to be kept up to
     * date, without sending a potentially large amount of active health checking traffic for no
     * reason. Once a cluster has been used for traffic routing, Envoy will shift back to using the
     * standard health check interval that is defined. Note that this interval takes precedence over
     * any other.
     *
     * The default value for "no traffic interval" is 60 seconds.
     *
     * @generated from field: google.protobuf.Duration no_traffic_interval = 12;
     */
    noTrafficInterval;
    /**
     * The "unhealthy interval" is a health check interval that is used for hosts that are marked as
     * unhealthy. As soon as the host is marked as healthy, Envoy will shift back to using the
     * standard health check interval that is defined.
     *
     * The default value for "unhealthy interval" is the same as "interval".
     *
     * @generated from field: google.protobuf.Duration unhealthy_interval = 14;
     */
    unhealthyInterval;
    /**
     * The "unhealthy edge interval" is a special health check interval that is used for the first
     * health check right after a host is marked as unhealthy. For subsequent health checks
     * Envoy will shift back to using either "unhealthy interval" if present or the standard health
     * check interval that is defined.
     *
     * The default value for "unhealthy edge interval" is the same as "unhealthy interval".
     *
     * @generated from field: google.protobuf.Duration unhealthy_edge_interval = 15;
     */
    unhealthyEdgeInterval;
    /**
     * The "healthy edge interval" is a special health check interval that is used for the first
     * health check right after a host is marked as healthy. For subsequent health checks
     * Envoy will shift back to using the standard health check interval that is defined.
     *
     * The default value for "healthy edge interval" is the same as the default interval.
     *
     * @generated from field: google.protobuf.Duration healthy_edge_interval = 16;
     */
    healthyEdgeInterval;
    /**
     * Specifies the path to the :ref:`health check event log <arch_overview_health_check_logging>`.
     * If empty, no event log will be written.
     *
     * @generated from field: string event_log_path = 17;
     */
    eventLogPath = "";
    /**
     * [#not-implemented-hide:]
     * The gRPC service for the health check event service.
     * If empty, health check events won't be sent to a remote endpoint.
     *
     * @generated from field: envoy.api.v2.core.EventServiceConfig event_service = 22;
     */
    eventService;
    /**
     * If set to true, health check failure events will always be logged. If set to false, only the
     * initial health check failure event will be logged.
     * The default value is false.
     *
     * @generated from field: bool always_log_health_check_failures = 19;
     */
    alwaysLogHealthCheckFailures = false;
    /**
     * This allows overriding the cluster TLS settings, just for health check connections.
     *
     * @generated from field: envoy.api.v2.core.HealthCheck.TlsOptions tls_options = 21;
     */
    tlsOptions;
    constructor(data) {
        super();
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static runtime = protobuf_1.proto3;
    static typeName = "envoy.api.v2.core.HealthCheck";
    static fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "timeout", kind: "message", T: duration_pb_1.Duration },
        { no: 2, name: "interval", kind: "message", T: duration_pb_1.Duration },
        { no: 20, name: "initial_jitter", kind: "message", T: duration_pb_1.Duration },
        { no: 3, name: "interval_jitter", kind: "message", T: duration_pb_1.Duration },
        { no: 18, name: "interval_jitter_percent", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
        { no: 4, name: "unhealthy_threshold", kind: "message", T: wrappers_pb_1.UInt32Value },
        { no: 5, name: "healthy_threshold", kind: "message", T: wrappers_pb_1.UInt32Value },
        { no: 6, name: "alt_port", kind: "message", T: wrappers_pb_1.UInt32Value },
        { no: 7, name: "reuse_connection", kind: "message", T: wrappers_pb_1.BoolValue },
        { no: 8, name: "http_health_check", kind: "message", T: HealthCheck_HttpHealthCheck, oneof: "health_checker" },
        { no: 9, name: "tcp_health_check", kind: "message", T: HealthCheck_TcpHealthCheck, oneof: "health_checker" },
        { no: 11, name: "grpc_health_check", kind: "message", T: HealthCheck_GrpcHealthCheck, oneof: "health_checker" },
        { no: 13, name: "custom_health_check", kind: "message", T: HealthCheck_CustomHealthCheck, oneof: "health_checker" },
        { no: 12, name: "no_traffic_interval", kind: "message", T: duration_pb_1.Duration },
        { no: 14, name: "unhealthy_interval", kind: "message", T: duration_pb_1.Duration },
        { no: 15, name: "unhealthy_edge_interval", kind: "message", T: duration_pb_1.Duration },
        { no: 16, name: "healthy_edge_interval", kind: "message", T: duration_pb_1.Duration },
        { no: 17, name: "event_log_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
        { no: 22, name: "event_service", kind: "message", T: event_service_config_pb_1.EventServiceConfig },
        { no: 19, name: "always_log_health_check_failures", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
        { no: 21, name: "tls_options", kind: "message", T: HealthCheck_TlsOptions },
    ]);
    static fromBinary(bytes, options) {
        return new HealthCheck().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new HealthCheck().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new HealthCheck().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(HealthCheck, a, b);
    }
}
exports.HealthCheck = HealthCheck;
/**
 * Describes the encoding of the payload bytes in the payload.
 *
 * @generated from message envoy.api.v2.core.HealthCheck.Payload
 */
class HealthCheck_Payload extends protobuf_1.Message {
    /**
     * @generated from oneof envoy.api.v2.core.HealthCheck.Payload.payload
     */
    payload = { case: undefined };
    constructor(data) {
        super();
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static runtime = protobuf_1.proto3;
    static typeName = "envoy.api.v2.core.HealthCheck.Payload";
    static fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "text", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "payload" },
        { no: 2, name: "binary", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "payload" },
    ]);
    static fromBinary(bytes, options) {
        return new HealthCheck_Payload().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new HealthCheck_Payload().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new HealthCheck_Payload().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(HealthCheck_Payload, a, b);
    }
}
exports.HealthCheck_Payload = HealthCheck_Payload;
/**
 * [#next-free-field: 12]
 *
 * @generated from message envoy.api.v2.core.HealthCheck.HttpHealthCheck
 */
class HealthCheck_HttpHealthCheck extends protobuf_1.Message {
    /**
     * The value of the host header in the HTTP health check request. If
     * left empty (default value), the name of the cluster this health check is associated
     * with will be used. The host header can be customized for a specific endpoint by setting the
     * :ref:`hostname <envoy_api_field_endpoint.Endpoint.HealthCheckConfig.hostname>` field.
     *
     * @generated from field: string host = 1;
     */
    host = "";
    /**
     * Specifies the HTTP path that will be requested during health checking. For example
     * *\/healthcheck*.
     *
     * @generated from field: string path = 2;
     */
    path = "";
    /**
     * [#not-implemented-hide:] HTTP specific payload.
     *
     * @generated from field: envoy.api.v2.core.HealthCheck.Payload send = 3;
     */
    send;
    /**
     * [#not-implemented-hide:] HTTP specific response.
     *
     * @generated from field: envoy.api.v2.core.HealthCheck.Payload receive = 4;
     */
    receive;
    /**
     * An optional service name parameter which is used to validate the identity of
     * the health checked cluster. See the :ref:`architecture overview
     * <arch_overview_health_checking_identity>` for more information.
     *
     * .. attention::
     *
     *   This field has been deprecated in favor of `service_name_matcher` for better flexibility
     *   over matching with service-cluster name.
     *
     * @generated from field: string service_name = 5 [deprecated = true];
     * @deprecated
     */
    serviceName = "";
    /**
     * Specifies a list of HTTP headers that should be added to each request that is sent to the
     * health checked cluster. For more information, including details on header value syntax, see
     * the documentation on :ref:`custom request headers
     * <config_http_conn_man_headers_custom_request_headers>`.
     *
     * @generated from field: repeated envoy.api.v2.core.HeaderValueOption request_headers_to_add = 6;
     */
    requestHeadersToAdd = [];
    /**
     * Specifies a list of HTTP headers that should be removed from each request that is sent to the
     * health checked cluster.
     *
     * @generated from field: repeated string request_headers_to_remove = 8;
     */
    requestHeadersToRemove = [];
    /**
     * If set, health checks will be made using http/2.
     * Deprecated, use :ref:`codec_client_type
     * <envoy_api_field_core.HealthCheck.HttpHealthCheck.codec_client_type>` instead.
     *
     * @generated from field: bool use_http2 = 7 [deprecated = true];
     * @deprecated
     */
    useHttp2 = false;
    /**
     * Specifies a list of HTTP response statuses considered healthy. If provided, replaces default
     * 200-only policy - 200 must be included explicitly as needed. Ranges follow half-open
     * semantics of :ref:`Int64Range <envoy_api_msg_type.Int64Range>`. The start and end of each
     * range are required. Only statuses in the range [100, 600) are allowed.
     *
     * @generated from field: repeated envoy.type.Int64Range expected_statuses = 9;
     */
    expectedStatuses = [];
    /**
     * Use specified application protocol for health checks.
     *
     * @generated from field: envoy.type.CodecClientType codec_client_type = 10;
     */
    codecClientType = http_pb_1.CodecClientType.HTTP1;
    /**
     * An optional service name parameter which is used to validate the identity of
     * the health checked cluster using a :ref:`StringMatcher
     * <envoy_api_msg_type.matcher.StringMatcher>`. See the :ref:`architecture overview
     * <arch_overview_health_checking_identity>` for more information.
     *
     * @generated from field: envoy.type.matcher.StringMatcher service_name_matcher = 11;
     */
    serviceNameMatcher;
    constructor(data) {
        super();
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static runtime = protobuf_1.proto3;
    static typeName = "envoy.api.v2.core.HealthCheck.HttpHealthCheck";
    static fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "host", kind: "scalar", T: 9 /* ScalarType.STRING */ },
        { no: 2, name: "path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
        { no: 3, name: "send", kind: "message", T: HealthCheck_Payload },
        { no: 4, name: "receive", kind: "message", T: HealthCheck_Payload },
        { no: 5, name: "service_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
        { no: 6, name: "request_headers_to_add", kind: "message", T: base_pb_1.HeaderValueOption, repeated: true },
        { no: 8, name: "request_headers_to_remove", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
        { no: 7, name: "use_http2", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
        { no: 9, name: "expected_statuses", kind: "message", T: range_pb_1.Int64Range, repeated: true },
        { no: 10, name: "codec_client_type", kind: "enum", T: protobuf_1.proto3.getEnumType(http_pb_1.CodecClientType) },
        { no: 11, name: "service_name_matcher", kind: "message", T: string_pb_1.StringMatcher },
    ]);
    static fromBinary(bytes, options) {
        return new HealthCheck_HttpHealthCheck().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new HealthCheck_HttpHealthCheck().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new HealthCheck_HttpHealthCheck().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(HealthCheck_HttpHealthCheck, a, b);
    }
}
exports.HealthCheck_HttpHealthCheck = HealthCheck_HttpHealthCheck;
/**
 * @generated from message envoy.api.v2.core.HealthCheck.TcpHealthCheck
 */
class HealthCheck_TcpHealthCheck extends protobuf_1.Message {
    /**
     * Empty payloads imply a connect-only health check.
     *
     * @generated from field: envoy.api.v2.core.HealthCheck.Payload send = 1;
     */
    send;
    /**
     * When checking the response, “fuzzy” matching is performed such that each
     * binary block must be found, and in the order specified, but not
     * necessarily contiguous.
     *
     * @generated from field: repeated envoy.api.v2.core.HealthCheck.Payload receive = 2;
     */
    receive = [];
    constructor(data) {
        super();
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static runtime = protobuf_1.proto3;
    static typeName = "envoy.api.v2.core.HealthCheck.TcpHealthCheck";
    static fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "send", kind: "message", T: HealthCheck_Payload },
        { no: 2, name: "receive", kind: "message", T: HealthCheck_Payload, repeated: true },
    ]);
    static fromBinary(bytes, options) {
        return new HealthCheck_TcpHealthCheck().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new HealthCheck_TcpHealthCheck().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new HealthCheck_TcpHealthCheck().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(HealthCheck_TcpHealthCheck, a, b);
    }
}
exports.HealthCheck_TcpHealthCheck = HealthCheck_TcpHealthCheck;
/**
 * @generated from message envoy.api.v2.core.HealthCheck.RedisHealthCheck
 */
class HealthCheck_RedisHealthCheck extends protobuf_1.Message {
    /**
     * If set, optionally perform ``EXISTS <key>`` instead of ``PING``. A return value
     * from Redis of 0 (does not exist) is considered a passing healthcheck. A return value other
     * than 0 is considered a failure. This allows the user to mark a Redis instance for maintenance
     * by setting the specified key to any value and waiting for traffic to drain.
     *
     * @generated from field: string key = 1;
     */
    key = "";
    constructor(data) {
        super();
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static runtime = protobuf_1.proto3;
    static typeName = "envoy.api.v2.core.HealthCheck.RedisHealthCheck";
    static fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    ]);
    static fromBinary(bytes, options) {
        return new HealthCheck_RedisHealthCheck().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new HealthCheck_RedisHealthCheck().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new HealthCheck_RedisHealthCheck().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(HealthCheck_RedisHealthCheck, a, b);
    }
}
exports.HealthCheck_RedisHealthCheck = HealthCheck_RedisHealthCheck;
/**
 * `grpc.health.v1.Health
 * <https://github.com/grpc/grpc/blob/master/src/proto/grpc/health/v1/health.proto>`_-based
 * healthcheck. See `gRPC doc <https://github.com/grpc/grpc/blob/master/doc/health-checking.md>`_
 * for details.
 *
 * @generated from message envoy.api.v2.core.HealthCheck.GrpcHealthCheck
 */
class HealthCheck_GrpcHealthCheck extends protobuf_1.Message {
    /**
     * An optional service name parameter which will be sent to gRPC service in
     * `grpc.health.v1.HealthCheckRequest
     * <https://github.com/grpc/grpc/blob/master/src/proto/grpc/health/v1/health.proto#L20>`_.
     * message. See `gRPC health-checking overview
     * <https://github.com/grpc/grpc/blob/master/doc/health-checking.md>`_ for more information.
     *
     * @generated from field: string service_name = 1;
     */
    serviceName = "";
    /**
     * The value of the :authority header in the gRPC health check request. If
     * left empty (default value), the name of the cluster this health check is associated
     * with will be used. The authority header can be customized for a specific endpoint by setting
     * the :ref:`hostname <envoy_api_field_endpoint.Endpoint.HealthCheckConfig.hostname>` field.
     *
     * @generated from field: string authority = 2;
     */
    authority = "";
    constructor(data) {
        super();
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static runtime = protobuf_1.proto3;
    static typeName = "envoy.api.v2.core.HealthCheck.GrpcHealthCheck";
    static fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "service_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
        { no: 2, name: "authority", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    ]);
    static fromBinary(bytes, options) {
        return new HealthCheck_GrpcHealthCheck().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new HealthCheck_GrpcHealthCheck().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new HealthCheck_GrpcHealthCheck().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(HealthCheck_GrpcHealthCheck, a, b);
    }
}
exports.HealthCheck_GrpcHealthCheck = HealthCheck_GrpcHealthCheck;
/**
 * Custom health check.
 *
 * @generated from message envoy.api.v2.core.HealthCheck.CustomHealthCheck
 */
class HealthCheck_CustomHealthCheck extends protobuf_1.Message {
    /**
     * The registered name of the custom health checker.
     *
     * @generated from field: string name = 1;
     */
    name = "";
    /**
     * A custom health checker specific configuration which depends on the custom health checker
     * being instantiated. See :api:`envoy/config/health_checker` for reference.
     *
     * @generated from oneof envoy.api.v2.core.HealthCheck.CustomHealthCheck.config_type
     */
    configType = { case: undefined };
    constructor(data) {
        super();
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static runtime = protobuf_1.proto3;
    static typeName = "envoy.api.v2.core.HealthCheck.CustomHealthCheck";
    static fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
        { no: 2, name: "config", kind: "message", T: struct_pb_1.Struct, oneof: "config_type" },
        { no: 3, name: "typed_config", kind: "message", T: any_pb_1.Any, oneof: "config_type" },
    ]);
    static fromBinary(bytes, options) {
        return new HealthCheck_CustomHealthCheck().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new HealthCheck_CustomHealthCheck().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new HealthCheck_CustomHealthCheck().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(HealthCheck_CustomHealthCheck, a, b);
    }
}
exports.HealthCheck_CustomHealthCheck = HealthCheck_CustomHealthCheck;
/**
 * Health checks occur over the transport socket specified for the cluster. This implies that if a
 * cluster is using a TLS-enabled transport socket, the health check will also occur over TLS.
 *
 * This allows overriding the cluster TLS settings, just for health check connections.
 *
 * @generated from message envoy.api.v2.core.HealthCheck.TlsOptions
 */
class HealthCheck_TlsOptions extends protobuf_1.Message {
    /**
     * Specifies the ALPN protocols for health check connections. This is useful if the
     * corresponding upstream is using ALPN-based :ref:`FilterChainMatch
     * <envoy_api_msg_listener.FilterChainMatch>` along with different protocols for health checks
     * versus data connections. If empty, no ALPN protocols will be set on health check connections.
     *
     * @generated from field: repeated string alpn_protocols = 1;
     */
    alpnProtocols = [];
    constructor(data) {
        super();
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static runtime = protobuf_1.proto3;
    static typeName = "envoy.api.v2.core.HealthCheck.TlsOptions";
    static fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "alpn_protocols", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    ]);
    static fromBinary(bytes, options) {
        return new HealthCheck_TlsOptions().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new HealthCheck_TlsOptions().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new HealthCheck_TlsOptions().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(HealthCheck_TlsOptions, a, b);
    }
}
exports.HealthCheck_TlsOptions = HealthCheck_TlsOptions;
