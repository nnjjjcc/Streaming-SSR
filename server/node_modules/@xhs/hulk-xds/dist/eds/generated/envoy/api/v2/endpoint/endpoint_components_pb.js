"use strict";
// @generated by protoc-gen-es v1.2.0 with parameter "target=ts,import_extension=none"
// @generated from file envoy/api/v2/endpoint/endpoint_components.proto (package envoy.api.v2.endpoint, syntax proto3)
/* eslint-disable */
// @ts-nocheck
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalityLbEndpoints = exports.LbEndpoint = exports.Endpoint_HealthCheckConfig = exports.Endpoint = void 0;
const protobuf_1 = require("@bufbuild/protobuf");
const address_pb_1 = require("../core/address_pb");
const health_check_pb_1 = require("../core/health_check_pb");
const base_pb_1 = require("../core/base_pb");
const wrappers_pb_1 = require("../../../../google/protobuf/wrappers_pb");
/**
 * Upstream host identifier.
 *
 * @generated from message envoy.api.v2.endpoint.Endpoint
 */
class Endpoint extends protobuf_1.Message {
    /**
     * The upstream host address.
     *
     * .. attention::
     *
     *   The form of host address depends on the given cluster type. For STATIC or EDS,
     *   it is expected to be a direct IP address (or something resolvable by the
     *   specified :ref:`resolver <envoy_api_field_core.SocketAddress.resolver_name>`
     *   in the Address). For LOGICAL or STRICT DNS, it is expected to be hostname,
     *   and will be resolved via DNS.
     *
     * @generated from field: envoy.api.v2.core.Address address = 1;
     */
    address;
    /**
     * The optional health check configuration is used as configuration for the
     * health checker to contact the health checked host.
     *
     * .. attention::
     *
     *   This takes into effect only for upstream clusters with
     *   :ref:`active health checking <arch_overview_health_checking>` enabled.
     *
     * @generated from field: envoy.api.v2.endpoint.Endpoint.HealthCheckConfig health_check_config = 2;
     */
    healthCheckConfig;
    /**
     * The hostname associated with this endpoint. This hostname is not used for routing or address
     * resolution. If provided, it will be associated with the endpoint, and can be used for features
     * that require a hostname, like
     * :ref:`auto_host_rewrite <envoy_api_field_route.RouteAction.auto_host_rewrite>`.
     *
     * @generated from field: string hostname = 3;
     */
    hostname = "";
    constructor(data) {
        super();
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static runtime = protobuf_1.proto3;
    static typeName = "envoy.api.v2.endpoint.Endpoint";
    static fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "address", kind: "message", T: address_pb_1.Address },
        { no: 2, name: "health_check_config", kind: "message", T: Endpoint_HealthCheckConfig },
        { no: 3, name: "hostname", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    ]);
    static fromBinary(bytes, options) {
        return new Endpoint().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Endpoint().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Endpoint().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(Endpoint, a, b);
    }
}
exports.Endpoint = Endpoint;
/**
 * The optional health check configuration.
 *
 * @generated from message envoy.api.v2.endpoint.Endpoint.HealthCheckConfig
 */
class Endpoint_HealthCheckConfig extends protobuf_1.Message {
    /**
     * Optional alternative health check port value.
     *
     * By default the health check address port of an upstream host is the same
     * as the host's serving address port. This provides an alternative health
     * check port. Setting this with a non-zero value allows an upstream host
     * to have different health check address port.
     *
     * @generated from field: uint32 port_value = 1;
     */
    portValue = 0;
    /**
     * By default, the host header for L7 health checks is controlled by cluster level configuration
     * (see: :ref:`host <envoy_api_field_core.HealthCheck.HttpHealthCheck.host>` and
     * :ref:`authority <envoy_api_field_core.HealthCheck.GrpcHealthCheck.authority>`). Setting this
     * to a non-empty value allows overriding the cluster level configuration for a specific
     * endpoint.
     *
     * @generated from field: string hostname = 2;
     */
    hostname = "";
    constructor(data) {
        super();
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static runtime = protobuf_1.proto3;
    static typeName = "envoy.api.v2.endpoint.Endpoint.HealthCheckConfig";
    static fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "port_value", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
        { no: 2, name: "hostname", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    ]);
    static fromBinary(bytes, options) {
        return new Endpoint_HealthCheckConfig().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new Endpoint_HealthCheckConfig().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new Endpoint_HealthCheckConfig().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(Endpoint_HealthCheckConfig, a, b);
    }
}
exports.Endpoint_HealthCheckConfig = Endpoint_HealthCheckConfig;
/**
 * An Endpoint that Envoy can route traffic to.
 * [#next-free-field: 6]
 *
 * @generated from message envoy.api.v2.endpoint.LbEndpoint
 */
class LbEndpoint extends protobuf_1.Message {
    /**
     * Upstream host identifier or a named reference.
     *
     * @generated from oneof envoy.api.v2.endpoint.LbEndpoint.host_identifier
     */
    hostIdentifier = { case: undefined };
    /**
     * Optional health status when known and supplied by EDS server.
     *
     * @generated from field: envoy.api.v2.core.HealthStatus health_status = 2;
     */
    healthStatus = health_check_pb_1.HealthStatus.UNKNOWN;
    /**
     * The endpoint metadata specifies values that may be used by the load
     * balancer to select endpoints in a cluster for a given request. The filter
     * name should be specified as *envoy.lb*. An example boolean key-value pair
     * is *canary*, providing the optional canary status of the upstream host.
     * This may be matched against in a route's
     * :ref:`RouteAction <envoy_api_msg_route.RouteAction>` metadata_match field
     * to subset the endpoints considered in cluster load balancing.
     *
     * @generated from field: envoy.api.v2.core.Metadata metadata = 3;
     */
    metadata;
    /**
     * The optional load balancing weight of the upstream host; at least 1.
     * Envoy uses the load balancing weight in some of the built in load
     * balancers. The load balancing weight for an endpoint is divided by the sum
     * of the weights of all endpoints in the endpoint's locality to produce a
     * percentage of traffic for the endpoint. This percentage is then further
     * weighted by the endpoint's locality's load balancing weight from
     * LocalityLbEndpoints. If unspecified, each host is presumed to have equal
     * weight in a locality. The sum of the weights of all endpoints in the
     * endpoint's locality must not exceed uint32_t maximal value (4294967295).
     *
     * @generated from field: google.protobuf.UInt32Value load_balancing_weight = 4;
     */
    loadBalancingWeight;
    constructor(data) {
        super();
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static runtime = protobuf_1.proto3;
    static typeName = "envoy.api.v2.endpoint.LbEndpoint";
    static fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "endpoint", kind: "message", T: Endpoint, oneof: "host_identifier" },
        { no: 5, name: "endpoint_name", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "host_identifier" },
        { no: 2, name: "health_status", kind: "enum", T: protobuf_1.proto3.getEnumType(health_check_pb_1.HealthStatus) },
        { no: 3, name: "metadata", kind: "message", T: base_pb_1.Metadata },
        { no: 4, name: "load_balancing_weight", kind: "message", T: wrappers_pb_1.UInt32Value },
    ]);
    static fromBinary(bytes, options) {
        return new LbEndpoint().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new LbEndpoint().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new LbEndpoint().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(LbEndpoint, a, b);
    }
}
exports.LbEndpoint = LbEndpoint;
/**
 * A group of endpoints belonging to a Locality.
 * One can have multiple LocalityLbEndpoints for a locality, but this is
 * generally only done if the different groups need to have different load
 * balancing weights or different priorities.
 * [#next-free-field: 7]
 *
 * @generated from message envoy.api.v2.endpoint.LocalityLbEndpoints
 */
class LocalityLbEndpoints extends protobuf_1.Message {
    /**
     * Identifies location of where the upstream hosts run.
     *
     * @generated from field: envoy.api.v2.core.Locality locality = 1;
     */
    locality;
    /**
     * The group of endpoints belonging to the locality specified.
     *
     * @generated from field: repeated envoy.api.v2.endpoint.LbEndpoint lb_endpoints = 2;
     */
    lbEndpoints = [];
    /**
     * Optional: Per priority/region/zone/sub_zone weight; at least 1. The load
     * balancing weight for a locality is divided by the sum of the weights of all
     * localities  at the same priority level to produce the effective percentage
     * of traffic for the locality. The sum of the weights of all localities at
     * the same priority level must not exceed uint32_t maximal value (4294967295).
     *
     * Locality weights are only considered when :ref:`locality weighted load
     * balancing <arch_overview_load_balancing_locality_weighted_lb>` is
     * configured. These weights are ignored otherwise. If no weights are
     * specified when locality weighted load balancing is enabled, the locality is
     * assigned no load.
     *
     * @generated from field: google.protobuf.UInt32Value load_balancing_weight = 3;
     */
    loadBalancingWeight;
    /**
     * Optional: the priority for this LocalityLbEndpoints. If unspecified this will
     * default to the highest priority (0).
     *
     * Under usual circumstances, Envoy will only select endpoints for the highest
     * priority (0). In the event all endpoints for a particular priority are
     * unavailable/unhealthy, Envoy will fail over to selecting endpoints for the
     * next highest priority group.
     *
     * Priorities should range from 0 (highest) to N (lowest) without skipping.
     *
     * @generated from field: uint32 priority = 5;
     */
    priority = 0;
    /**
     * Optional: Per locality proximity value which indicates how close this
     * locality is from the source locality. This value only provides ordering
     * information (lower the value, closer it is to the source locality).
     * This will be consumed by load balancing schemes that need proximity order
     * to determine where to route the requests.
     * [#not-implemented-hide:]
     *
     * @generated from field: google.protobuf.UInt32Value proximity = 6;
     */
    proximity;
    constructor(data) {
        super();
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static runtime = protobuf_1.proto3;
    static typeName = "envoy.api.v2.endpoint.LocalityLbEndpoints";
    static fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "locality", kind: "message", T: base_pb_1.Locality },
        { no: 2, name: "lb_endpoints", kind: "message", T: LbEndpoint, repeated: true },
        { no: 3, name: "load_balancing_weight", kind: "message", T: wrappers_pb_1.UInt32Value },
        { no: 5, name: "priority", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
        { no: 6, name: "proximity", kind: "message", T: wrappers_pb_1.UInt32Value },
    ]);
    static fromBinary(bytes, options) {
        return new LocalityLbEndpoints().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new LocalityLbEndpoints().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new LocalityLbEndpoints().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(LocalityLbEndpoints, a, b);
    }
}
exports.LocalityLbEndpoints = LocalityLbEndpoints;
