"use strict";
// @generated by protoc-gen-es v1.2.0 with parameter "target=ts,import_extension=none"
// @generated from file envoy/api/v2/endpoint.proto (package envoy.api.v2, syntax proto3)
/* eslint-disable */
// @ts-nocheck
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClusterLoadAssignment_Policy_DropOverload = exports.ClusterLoadAssignment_Policy = exports.ClusterLoadAssignment = void 0;
const protobuf_1 = require("@bufbuild/protobuf");
const endpoint_components_pb_1 = require("./endpoint/endpoint_components_pb");
const duration_pb_1 = require("../../../google/protobuf/duration_pb");
const wrappers_pb_1 = require("../../../google/protobuf/wrappers_pb");
const percent_pb_1 = require("../../type/percent_pb");
/**
 * Each route from RDS will map to a single cluster or traffic split across
 * clusters using weights expressed in the RDS WeightedCluster.
 *
 * With EDS, each cluster is treated independently from a LB perspective, with
 * LB taking place between the Localities within a cluster and at a finer
 * granularity between the hosts within a locality. The percentage of traffic
 * for each endpoint is determined by both its load_balancing_weight, and the
 * load_balancing_weight of its locality. First, a locality will be selected,
 * then an endpoint within that locality will be chose based on its weight.
 * [#next-free-field: 6]
 *
 * @generated from message envoy.api.v2.ClusterLoadAssignment
 */
class ClusterLoadAssignment extends protobuf_1.Message {
    /**
     * Name of the cluster. This will be the :ref:`service_name
     * <envoy_api_field_Cluster.EdsClusterConfig.service_name>` value if specified
     * in the cluster :ref:`EdsClusterConfig
     * <envoy_api_msg_Cluster.EdsClusterConfig>`.
     *
     * @generated from field: string cluster_name = 1;
     */
    clusterName = "";
    /**
     * List of endpoints to load balance to.
     *
     * @generated from field: repeated envoy.api.v2.endpoint.LocalityLbEndpoints endpoints = 2;
     */
    endpoints = [];
    /**
     * Map of named endpoints that can be referenced in LocalityLbEndpoints.
     * [#not-implemented-hide:]
     *
     * @generated from field: map<string, envoy.api.v2.endpoint.Endpoint> named_endpoints = 5;
     */
    namedEndpoints = {};
    /**
     * Load balancing policy settings.
     *
     * @generated from field: envoy.api.v2.ClusterLoadAssignment.Policy policy = 4;
     */
    policy;
    constructor(data) {
        super();
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static runtime = protobuf_1.proto3;
    static typeName = "envoy.api.v2.ClusterLoadAssignment";
    static fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "cluster_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
        { no: 2, name: "endpoints", kind: "message", T: endpoint_components_pb_1.LocalityLbEndpoints, repeated: true },
        { no: 5, name: "named_endpoints", kind: "map", K: 9 /* ScalarType.STRING */, V: { kind: "message", T: endpoint_components_pb_1.Endpoint } },
        { no: 4, name: "policy", kind: "message", T: ClusterLoadAssignment_Policy },
    ]);
    static fromBinary(bytes, options) {
        return new ClusterLoadAssignment().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new ClusterLoadAssignment().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new ClusterLoadAssignment().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(ClusterLoadAssignment, a, b);
    }
}
exports.ClusterLoadAssignment = ClusterLoadAssignment;
/**
 * Load balancing policy settings.
 * [#next-free-field: 6]
 *
 * @generated from message envoy.api.v2.ClusterLoadAssignment.Policy
 */
class ClusterLoadAssignment_Policy extends protobuf_1.Message {
    /**
     * Action to trim the overall incoming traffic to protect the upstream
     * hosts. This action allows protection in case the hosts are unable to
     * recover from an outage, or unable to autoscale or unable to handle
     * incoming traffic volume for any reason.
     *
     * At the client each category is applied one after the other to generate
     * the 'actual' drop percentage on all outgoing traffic. For example:
     *
     * .. code-block:: json
     *
     *  { "drop_overloads": [
     *      { "category": "throttle", "drop_percentage": 60 }
     *      { "category": "lb", "drop_percentage": 50 }
     *  ]}
     *
     * The actual drop percentages applied to the traffic at the clients will be
     *    "throttle"_drop = 60%
     *    "lb"_drop = 20%  // 50% of the remaining 'actual' load, which is 40%.
     *    actual_outgoing_load = 20% // remaining after applying all categories.
     * [#not-implemented-hide:]
     *
     * @generated from field: repeated envoy.api.v2.ClusterLoadAssignment.Policy.DropOverload drop_overloads = 2;
     */
    dropOverloads = [];
    /**
     * Priority levels and localities are considered overprovisioned with this
     * factor (in percentage). This means that we don't consider a priority
     * level or locality unhealthy until the percentage of healthy hosts
     * multiplied by the overprovisioning factor drops below 100.
     * With the default value 140(1.4), Envoy doesn't consider a priority level
     * or a locality unhealthy until their percentage of healthy hosts drops
     * below 72%. For example:
     *
     * .. code-block:: json
     *
     *  { "overprovisioning_factor": 100 }
     *
     * Read more at :ref:`priority levels <arch_overview_load_balancing_priority_levels>` and
     * :ref:`localities <arch_overview_load_balancing_locality_weighted_lb>`.
     *
     * @generated from field: google.protobuf.UInt32Value overprovisioning_factor = 3;
     */
    overprovisioningFactor;
    /**
     * The max time until which the endpoints from this assignment can be used.
     * If no new assignments are received before this time expires the endpoints
     * are considered stale and should be marked unhealthy.
     * Defaults to 0 which means endpoints never go stale.
     *
     * @generated from field: google.protobuf.Duration endpoint_stale_after = 4;
     */
    endpointStaleAfter;
    /**
     * The flag to disable overprovisioning. If it is set to true,
     * :ref:`overprovisioning factor
     * <arch_overview_load_balancing_overprovisioning_factor>` will be ignored
     * and Envoy will not perform graceful failover between priority levels or
     * localities as endpoints become unhealthy. Otherwise Envoy will perform
     * graceful failover as :ref:`overprovisioning factor
     * <arch_overview_load_balancing_overprovisioning_factor>` suggests.
     * [#not-implemented-hide:]
     *
     * @generated from field: bool disable_overprovisioning = 5 [deprecated = true];
     * @deprecated
     */
    disableOverprovisioning = false;
    constructor(data) {
        super();
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static runtime = protobuf_1.proto3;
    static typeName = "envoy.api.v2.ClusterLoadAssignment.Policy";
    static fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 2, name: "drop_overloads", kind: "message", T: ClusterLoadAssignment_Policy_DropOverload, repeated: true },
        { no: 3, name: "overprovisioning_factor", kind: "message", T: wrappers_pb_1.UInt32Value },
        { no: 4, name: "endpoint_stale_after", kind: "message", T: duration_pb_1.Duration },
        { no: 5, name: "disable_overprovisioning", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    ]);
    static fromBinary(bytes, options) {
        return new ClusterLoadAssignment_Policy().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new ClusterLoadAssignment_Policy().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new ClusterLoadAssignment_Policy().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(ClusterLoadAssignment_Policy, a, b);
    }
}
exports.ClusterLoadAssignment_Policy = ClusterLoadAssignment_Policy;
/**
 * [#not-implemented-hide:]
 *
 * @generated from message envoy.api.v2.ClusterLoadAssignment.Policy.DropOverload
 */
class ClusterLoadAssignment_Policy_DropOverload extends protobuf_1.Message {
    /**
     * Identifier for the policy specifying the drop.
     *
     * @generated from field: string category = 1;
     */
    category = "";
    /**
     * Percentage of traffic that should be dropped for the category.
     *
     * @generated from field: envoy.type.FractionalPercent drop_percentage = 2;
     */
    dropPercentage;
    constructor(data) {
        super();
        protobuf_1.proto3.util.initPartial(data, this);
    }
    static runtime = protobuf_1.proto3;
    static typeName = "envoy.api.v2.ClusterLoadAssignment.Policy.DropOverload";
    static fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "category", kind: "scalar", T: 9 /* ScalarType.STRING */ },
        { no: 2, name: "drop_percentage", kind: "message", T: percent_pb_1.FractionalPercent },
    ]);
    static fromBinary(bytes, options) {
        return new ClusterLoadAssignment_Policy_DropOverload().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
        return new ClusterLoadAssignment_Policy_DropOverload().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
        return new ClusterLoadAssignment_Policy_DropOverload().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
        return protobuf_1.proto3.util.equals(ClusterLoadAssignment_Policy_DropOverload, a, b);
    }
}
exports.ClusterLoadAssignment_Policy_DropOverload = ClusterLoadAssignment_Policy_DropOverload;
