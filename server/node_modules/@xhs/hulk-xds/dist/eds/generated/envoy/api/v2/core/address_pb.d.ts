import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { SocketOption } from "./socket_option_pb";
/**
 * @generated from message envoy.api.v2.core.Pipe
 */
export declare class Pipe extends Message<Pipe> {
    /**
     * Unix Domain Socket path. On Linux, paths starting with '@' will use the
     * abstract namespace. The starting '@' is replaced by a null byte by Envoy.
     * Paths starting with '@' will result in an error in environments other than
     * Linux.
     *
     * @generated from field: string path = 1;
     */
    path: string;
    /**
     * The mode for the Pipe. Not applicable for abstract sockets.
     *
     * @generated from field: uint32 mode = 2;
     */
    mode: number;
    constructor(data?: PartialMessage<Pipe>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "envoy.api.v2.core.Pipe";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Pipe;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Pipe;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Pipe;
    static equals(a: Pipe | PlainMessage<Pipe> | undefined, b: Pipe | PlainMessage<Pipe> | undefined): boolean;
}
/**
 * [#next-free-field: 7]
 *
 * @generated from message envoy.api.v2.core.SocketAddress
 */
export declare class SocketAddress extends Message<SocketAddress> {
    /**
     * @generated from field: envoy.api.v2.core.SocketAddress.Protocol protocol = 1;
     */
    protocol: SocketAddress_Protocol;
    /**
     * The address for this socket. :ref:`Listeners <config_listeners>` will bind
     * to the address. An empty address is not allowed. Specify ``0.0.0.0`` or ``::``
     * to bind to any address. [#comment:TODO(zuercher) reinstate when implemented:
     * It is possible to distinguish a Listener address via the prefix/suffix matching
     * in :ref:`FilterChainMatch <envoy_api_msg_listener.FilterChainMatch>`.] When used
     * within an upstream :ref:`BindConfig <envoy_api_msg_core.BindConfig>`, the address
     * controls the source address of outbound connections. For :ref:`clusters
     * <envoy_api_msg_Cluster>`, the cluster type determines whether the
     * address must be an IP (*STATIC* or *EDS* clusters) or a hostname resolved by DNS
     * (*STRICT_DNS* or *LOGICAL_DNS* clusters). Address resolution can be customized
     * via :ref:`resolver_name <envoy_api_field_core.SocketAddress.resolver_name>`.
     *
     * @generated from field: string address = 2;
     */
    address: string;
    /**
     * @generated from oneof envoy.api.v2.core.SocketAddress.port_specifier
     */
    portSpecifier: {
        /**
         * @generated from field: uint32 port_value = 3;
         */
        value: number;
        case: "portValue";
    } | {
        /**
         * This is only valid if :ref:`resolver_name
         * <envoy_api_field_core.SocketAddress.resolver_name>` is specified below and the
         * named resolver is capable of named port resolution.
         *
         * @generated from field: string named_port = 4;
         */
        value: string;
        case: "namedPort";
    } | {
        case: undefined;
        value?: undefined;
    };
    /**
     * The name of the custom resolver. This must have been registered with Envoy. If
     * this is empty, a context dependent default applies. If the address is a concrete
     * IP address, no resolution will occur. If address is a hostname this
     * should be set for resolution other than DNS. Specifying a custom resolver with
     * *STRICT_DNS* or *LOGICAL_DNS* will generate an error at runtime.
     *
     * @generated from field: string resolver_name = 5;
     */
    resolverName: string;
    /**
     * When binding to an IPv6 address above, this enables `IPv4 compatibility
     * <https://tools.ietf.org/html/rfc3493#page-11>`_. Binding to ``::`` will
     * allow both IPv4 and IPv6 connections, with peer IPv4 addresses mapped into
     * IPv6 space as ``::FFFF:<IPv4-address>``.
     *
     * @generated from field: bool ipv4_compat = 6;
     */
    ipv4Compat: boolean;
    constructor(data?: PartialMessage<SocketAddress>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "envoy.api.v2.core.SocketAddress";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SocketAddress;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SocketAddress;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SocketAddress;
    static equals(a: SocketAddress | PlainMessage<SocketAddress> | undefined, b: SocketAddress | PlainMessage<SocketAddress> | undefined): boolean;
}
/**
 * @generated from enum envoy.api.v2.core.SocketAddress.Protocol
 */
export declare enum SocketAddress_Protocol {
    /**
     * @generated from enum value: TCP = 0;
     */
    TCP = 0,
    /**
     * @generated from enum value: UDP = 1;
     */
    UDP = 1
}
/**
 * @generated from message envoy.api.v2.core.TcpKeepalive
 */
export declare class TcpKeepalive extends Message<TcpKeepalive> {
    /**
     * Maximum number of keepalive probes to send without response before deciding
     * the connection is dead. Default is to use the OS level configuration (unless
     * overridden, Linux defaults to 9.)
     *
     * @generated from field: google.protobuf.UInt32Value keepalive_probes = 1;
     */
    keepaliveProbes?: number;
    /**
     * The number of seconds a connection needs to be idle before keep-alive probes
     * start being sent. Default is to use the OS level configuration (unless
     * overridden, Linux defaults to 7200s (i.e., 2 hours.)
     *
     * @generated from field: google.protobuf.UInt32Value keepalive_time = 2;
     */
    keepaliveTime?: number;
    /**
     * The number of seconds between keep-alive probes. Default is to use the OS
     * level configuration (unless overridden, Linux defaults to 75s.)
     *
     * @generated from field: google.protobuf.UInt32Value keepalive_interval = 3;
     */
    keepaliveInterval?: number;
    constructor(data?: PartialMessage<TcpKeepalive>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "envoy.api.v2.core.TcpKeepalive";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TcpKeepalive;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TcpKeepalive;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TcpKeepalive;
    static equals(a: TcpKeepalive | PlainMessage<TcpKeepalive> | undefined, b: TcpKeepalive | PlainMessage<TcpKeepalive> | undefined): boolean;
}
/**
 * @generated from message envoy.api.v2.core.BindConfig
 */
export declare class BindConfig extends Message<BindConfig> {
    /**
     * The address to bind to when creating a socket.
     *
     * @generated from field: envoy.api.v2.core.SocketAddress source_address = 1;
     */
    sourceAddress?: SocketAddress;
    /**
     * Whether to set the *IP_FREEBIND* option when creating the socket. When this
     * flag is set to true, allows the :ref:`source_address
     * <envoy_api_field_UpstreamBindConfig.source_address>` to be an IP address
     * that is not configured on the system running Envoy. When this flag is set
     * to false, the option *IP_FREEBIND* is disabled on the socket. When this
     * flag is not set (default), the socket is not modified, i.e. the option is
     * neither enabled nor disabled.
     *
     * @generated from field: google.protobuf.BoolValue freebind = 2;
     */
    freebind?: boolean;
    /**
     * Additional socket options that may not be present in Envoy source code or
     * precompiled binaries.
     *
     * @generated from field: repeated envoy.api.v2.core.SocketOption socket_options = 3;
     */
    socketOptions: SocketOption[];
    constructor(data?: PartialMessage<BindConfig>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "envoy.api.v2.core.BindConfig";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BindConfig;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BindConfig;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BindConfig;
    static equals(a: BindConfig | PlainMessage<BindConfig> | undefined, b: BindConfig | PlainMessage<BindConfig> | undefined): boolean;
}
/**
 * Addresses specify either a logical or physical address and port, which are
 * used to tell Envoy where to bind/listen, connect to upstream and find
 * management servers.
 *
 * @generated from message envoy.api.v2.core.Address
 */
export declare class Address extends Message<Address> {
    /**
     * @generated from oneof envoy.api.v2.core.Address.address
     */
    address: {
        /**
         * @generated from field: envoy.api.v2.core.SocketAddress socket_address = 1;
         */
        value: SocketAddress;
        case: "socketAddress";
    } | {
        /**
         * @generated from field: envoy.api.v2.core.Pipe pipe = 2;
         */
        value: Pipe;
        case: "pipe";
    } | {
        case: undefined;
        value?: undefined;
    };
    constructor(data?: PartialMessage<Address>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "envoy.api.v2.core.Address";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Address;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Address;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Address;
    static equals(a: Address | PlainMessage<Address> | undefined, b: Address | PlainMessage<Address> | undefined): boolean;
}
/**
 * CidrRange specifies an IP Address and a prefix length to construct
 * the subnet mask for a `CIDR <https://tools.ietf.org/html/rfc4632>`_ range.
 *
 * @generated from message envoy.api.v2.core.CidrRange
 */
export declare class CidrRange extends Message<CidrRange> {
    /**
     * IPv4 or IPv6 address, e.g. ``192.0.0.0`` or ``2001:db8::``.
     *
     * @generated from field: string address_prefix = 1;
     */
    addressPrefix: string;
    /**
     * Length of prefix, e.g. 0, 32. Defaults to 0 when unset.
     *
     * @generated from field: google.protobuf.UInt32Value prefix_len = 2;
     */
    prefixLen?: number;
    constructor(data?: PartialMessage<CidrRange>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "envoy.api.v2.core.CidrRange";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CidrRange;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CidrRange;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CidrRange;
    static equals(a: CidrRange | PlainMessage<CidrRange> | undefined, b: CidrRange | PlainMessage<CidrRange> | undefined): boolean;
}
