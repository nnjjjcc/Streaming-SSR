"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EDS = exports.Mesh = void 0;
const https_1 = require("https");
const promises_1 = require("fs/promises");
const hulk_env_1 = require("@xhs/hulk-env");
const class_1 = require("./class");
class Mesh {
    static resource = ((0, hulk_env_1.isProd)() || (0, hulk_env_1.isStaging)() || (0, hulk_env_1.isSit)())
        ? (0, promises_1.access)('/etc/mesh/mesh-config.json')
            .then(() => (0, promises_1.readFile)('/etc/mesh/mesh-config.json', { encoding: 'utf8' })
            .then(res => JSON.parse(res))
            .then((res) => Object
            .entries(res.dependServices)
            .filter(([_, port]) => /^\d+$/.test(port))
            .reduce((a, [name, port]) => {
            Reflect.set(a, name, { ip: '0.0.0.0', port: Number(port), envTag: 'local-mesh' });
            return a;
        }, {})))
            .catch(() => undefined)
        : new Promise(resolve => {
            (0, https_1.get)('https://redcloud.devops.xiaohongshu.com/api/v1/services/main-sidecar?env=sit', res => {
                const data = [];
                res
                    .on('data', chunk => data.push(chunk))
                    .on('end', () => {
                    const { data: { dependencies } } = JSON.parse(Buffer.concat(data).toString());
                    resolve(dependencies
                        .filter(({ port }) => /^\d+$/.test(port))
                        .reduce((a, { name, port }) => {
                        Reflect.set(a, name, { ip: '10.4.44.243', port: Number(port), envTag: 'central-mesh' });
                        return a;
                    }, {}));
                });
            })
                .on('error', () => resolve(undefined));
        });
    static get(name) {
        return Mesh.resource
            .then(resource => {
            if (resource) {
                const address = Reflect.get(resource, name);
                if (address) {
                    return address;
                }
                throw new Error(`[hulk-xds] ${name} seems not registered as dependency, please check your mesh configuration.`);
            }
            else {
                throw new Error('[hulk-xds] mesh seems not initialized, please check your mesh configuration.');
            }
        });
    }
    get(name) {
        return Mesh.get(name);
    }
}
exports.Mesh = Mesh;
class EDS {
    static debug = (0, hulk_env_1.isDebug)();
    static notifiers = {};
    static terminate() {
        Object
            .values(EDS.notifiers)
            .forEach(notifier => notifier.terminate());
    }
    static key(options) {
        return `${options.name}+${options.protocol}`;
    }
    static onUpdate(options, listener) {
        const key = EDS.key(options);
        const existingNotifier = Reflect.get(EDS.notifiers, key);
        if (existingNotifier) {
            return existingNotifier.onUpdate(options, listener);
        }
        const notifier = new class_1.Notifier(options);
        Reflect.set(EDS.notifiers, key, notifier);
        return notifier.onUpdate(options, listener);
    }
    static get(options) {
        return (
        // eslint-disable-next-line no-nested-ternary
        options.envTag
            ? Promise.reject(new Error(`[hulk-xds] envTag: ${options.envTag} specified.`))
            : options.forceEDS
                ? Promise.reject(new Error('[hulk-xds] force eds.'))
                : Mesh.get(options.name))
            .catch((e) => {
            if (EDS.debug) {
                console.log(e.message);
                console.log('[hulk-xds] discovering %s via eds...', options.name);
            }
            const key = EDS.key(options);
            const existingNotifier = Reflect.get(EDS.notifiers, key);
            if (existingNotifier) {
                return existingNotifier
                    .get(options)
                    .then(({ address }) => {
                    if (EDS.debug) {
                        console.log('[hulk-xds] using %s@%s:%s(tag:%s)...', options.name, address.ip, address.port, address.envTag);
                    }
                    return address;
                });
            }
            const notifier = new class_1.Notifier(options);
            Reflect.set(EDS.notifiers, key, notifier);
            return notifier
                .get(options)
                .then(({ address }) => {
                if (EDS.debug) {
                    console.log('[hulk-xds] using %s@%s:%s(tag:%s)...', options.name, address.ip, address.port, address.envTag);
                }
                return address;
            });
        });
    }
    onUpdate(options, listener) {
        return EDS.onUpdate(options, listener);
    }
    get(options) {
        return EDS.get(options);
    }
    /** @deprecated This is a legacy api, will be deprecated after 0.4.0 */
    discovery(name) {
        const key = `${name}+__DEPRECATED__UNSETTLED__PROTOCOL__`;
        const existingNotifier = Reflect.get(EDS.notifiers, key);
        if (existingNotifier) {
            return existingNotifier;
        }
        // @ts-ignore
        const notifier = new class_1.Notifier({ name });
        Reflect.set(EDS.notifiers, key, notifier);
        return notifier;
    }
}
exports.EDS = EDS;
