"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable import/no-extraneous-dependencies */
const worker_threads_1 = require("worker_threads");
const hulk_env_1 = require("@xhs/hulk-env");
const connect_1 = require("@bufbuild/connect");
// @ts-ignore
const connect_node_1 = require("@bufbuild/connect-node");
const protocol_1 = require("@bufbuild/connect/protocol");
const Tag_1 = require("./class/Tag");
const struct_pb_1 = require("./generated/google/protobuf/struct_pb");
const base_pb_1 = require("./generated/envoy/api/v2/core/base_pb");
const endpoint_pb_1 = require("./generated/envoy/api/v2/endpoint_pb");
const discovery_pb_1 = require("./generated/envoy/api/v2/discovery_pb");
const eds_connect_1 = require("./generated/envoy/api/v2/eds_connect");
class ResourceSubscription {
    static typeUrl = 'type.googleapis.com/envoy.api.v2.ClusterLoadAssignment';
    static client = (0, connect_1.createPromiseClient)(eds_connect_1.EndpointDiscoveryService, (0, connect_node_1.createGrpcTransport)({ baseUrl: `http://${(0, hulk_env_1.getEDSHost)()}`, httpVersion: '2' }));
    static timeoutStep = 1000;
    static maxTimeout = ResourceSubscription.timeoutStep * 60;
    name;
    protocol;
    node;
    resource = {};
    request;
    listener;
    constructor(options, listener) {
        this.listener = listener;
        this.name = options.name;
        this.protocol = options.protocol;
        this.node = new base_pb_1.Node({
            userAgentName: 'sdk',
            locality: ((0, hulk_env_1.getRegion)() && (0, hulk_env_1.getZone)())
                ? new base_pb_1.Locality({
                    region: (0, hulk_env_1.getRegion)(),
                    zone: (0, hulk_env_1.getZone)(),
                })
                : undefined,
            cluster: (0, hulk_env_1.getAppId)(),
            id: `sidecar~${(0, hulk_env_1.getPodIP)() || (0, hulk_env_1.getIPv4)() || (0, hulk_env_1.getIPv6)()}~${(0, hulk_env_1.getHostname)()}.${(0, hulk_env_1.getNamespace)()}~${(0, hulk_env_1.getNamespace)()}.svc.cluster.local`,
            /** @legacy adapt legacy discovey api which passes no protocol */
            ...this.protocol && {
                metadata: new struct_pb_1.Struct({
                    fields: {
                        PROTOCOL: new struct_pb_1.Value({ kind: { case: 'stringValue', value: this.protocol } }),
                    },
                }),
            },
        });
        this.subscribe();
    }
    static isLocal(locality) {
        /** mesh will always be local */
        if (locality?.zone === 'rsm' || locality?.subZone === 'rsm') {
            return true;
        }
        const localRegion = (0, hulk_env_1.getRegion)();
        const localZone = (0, hulk_env_1.getZone)();
        if (localRegion || localZone) {
            if (locality) {
                if (localRegion && localZone) {
                    return locality?.region === localRegion && locality?.zone === localZone;
                }
                if (localRegion) {
                    return locality?.region === localRegion;
                }
                if (localZone) {
                    return locality?.zone === localZone;
                }
            }
            return false;
        }
        /** assume local everywhere when no region and zone in env */
        return true;
    }
    static parseMetadata({ filterMetadata }) {
        const metadata = {};
        const Tags = Reflect.get(filterMetadata, 'Tags')?.fields;
        if (Tags) {
            const appid = Reflect.get(Tags, 'appid')?.kind;
            const hostname = Reflect.get(Tags, 'hostname')?.kind;
            const tags = Reflect.get(Tags, 'tags')?.kind;
            const lane = Reflect.get(Tags, 'lane')?.kind;
            const weight = Reflect.get(Tags, 'weight')?.kind;
            Reflect
                .set(metadata, 'tags', {
                appid: appid?.case === 'stringValue' ? appid.value : undefined,
                hostname: hostname?.case === 'stringValue' ? hostname.value : undefined,
                // eslint-disable-next-line no-nested-ternary
                tags: tags?.case === 'stringValue'
                    ? tags.value
                    : lane?.case === 'stringValue'
                        ? lane.value
                        : undefined,
                weight: weight?.case === 'numberValue' ? weight.value : undefined,
            });
        }
        return metadata;
    }
    static parseLocality({ region, zone, subZone }) {
        return {
            region,
            zone,
            subZone,
        };
    }
    static parseResource({ resources }) {
        return resources
            .map(({ value }) => endpoint_pb_1.ClusterLoadAssignment.fromBinary(value))
            .reduce((a, { endpoints }) => ([...a, ...endpoints]), [])
            .reduce((acc, { locality, lbEndpoints = [], priority = 0 }) => acc
            .concat(lbEndpoints
            .reduce((a, { hostIdentifier, metadata }) => {
            if (hostIdentifier.case === 'endpoint') {
                const address = hostIdentifier.value.address?.address;
                if (address?.case === 'socketAddress') {
                    const { address: ip, portSpecifier: port } = address.value;
                    if (port.case === 'portValue') {
                        const parsedMetadata = metadata && ResourceSubscription.parseMetadata(metadata);
                        const parsedLocality = locality && ResourceSubscription.parseLocality(locality);
                        a
                            .push({
                            address: { ip, port: port.value, envTag: parsedMetadata?.tags?.tags || Tag_1.Tag.defaultEnvTag },
                            ...parsedMetadata && { metadata: parsedMetadata },
                            ...parsedLocality && { locality: parsedLocality },
                            priority,
                        });
                    }
                }
            }
            return a;
        }, [])), [])
            .sort((a, b) => a.priority - b.priority);
    }
    static createIdleTimeout() {
        const abort = new AbortController();
        let timeout;
        function refresh() {
            clearTimeout(timeout);
            timeout = setTimeout(() => abort.abort(), ResourceSubscription.maxTimeout);
        }
        refresh();
        return { abort, refresh };
    }
    terminate() {
        this.request?.close();
    }
    async subscribe(errorTimeout = 0) {
        let timeout = errorTimeout;
        const idleTimeout = ResourceSubscription.createIdleTimeout();
        this.request = (0, protocol_1.createWritableIterable)();
        this.request
            .write(new discovery_pb_1.DiscoveryRequest({
            typeUrl: ResourceSubscription.typeUrl,
            node: this.node,
            resourceNames: [this.name],
        }));
        try {
            for await (const res of ResourceSubscription.client.streamEndpoints(this.request, { signal: idleTimeout.abort.signal })) {
                timeout = 0;
                idleTimeout.refresh();
                this.update(res);
            }
        }
        catch (e) {
            this.terminate();
            if (e instanceof connect_1.ConnectError && e.code === connect_1.Code.Canceled) {
                process
                    .nextTick(() => this.subscribe());
            }
            else {
                setTimeout(() => this.subscribe(timeout <= ResourceSubscription.maxTimeout
                    ? timeout + ResourceSubscription.timeoutStep
                    : timeout / 2), timeout);
            }
        }
    }
    diff(target, envTag) {
        const [from, to] = [Reflect.get(this.resource, envTag), Reflect.get(target, envTag)];
        return (!from
            || !to
            || Array
                .from(new Set([...from, ...to]
                .map(({ address: { ip, port } }) => `${ip}:${port}`))).length !== to.length);
    }
    update(value) {
        const temp = {};
        const crossenv = {};
        ResourceSubscription
            .parseResource(value)
            .forEach(v => {
            const store = ResourceSubscription.isLocal(v.locality) ? temp : crossenv;
            const envTag = v.address.envTag;
            const existing = Reflect.get(store, envTag);
            if (existing) {
                const [{ priority }] = existing;
                if (v.priority === priority) {
                    existing.push(v);
                }
            }
            else {
                Reflect.set(store, envTag, [v]);
            }
        });
        Array
            .from(new Set([...Object.keys(temp), ...Object.keys(crossenv)]))
            .forEach(k => {
            if (!Reflect.has(temp, k)) {
                Reflect.set(temp, k, Reflect.get(crossenv, k));
            }
        });
        let changed = false;
        const diff = Array
            .from(new Set([...Object.keys(temp), ...Object.keys(this.resource)]))
            .reduce((a, c) => {
            const hasDiff = this.diff(temp, c);
            if (hasDiff) {
                changed = true;
                const resource = Reflect.get(temp, c);
                if (resource?.length) {
                    Reflect
                        .set(temp, c, 
                    // order resources to approximate eventually consistent load balancing
                    resource
                        .sort(({ address: A }, { address: B }) => (`${A.ip}:${A.port}` > `${B.ip}:${B.port}` ? 1 : -1)));
                }
            }
            return {
                ...a,
                [c]: hasDiff,
            };
        }, {});
        if (changed) {
            this.resource = temp;
            this.listener({ resource: this.resource, diff });
        }
    }
}
if (!worker_threads_1.isMainThread) {
    worker_threads_1.parentPort
        ?.on('message', (v) => {
        switch (v?.type) {
            case 'subscribe':
                return new ResourceSubscription(v.value, ({ resource, diff }) => worker_threads_1.parentPort?.postMessage({ resource, diff }));
            case 'exit':
                return process.exit(v.value);
            default:
                return undefined;
        }
    });
}
