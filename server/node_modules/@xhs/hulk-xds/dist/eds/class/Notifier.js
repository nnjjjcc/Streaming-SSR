"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Notifier = void 0;
const worker_threads_1 = require("worker_threads");
const hulk_metrics_1 = require("@xhs/hulk-metrics");
const Tag_1 = require("./Tag");
const worker_1 = require("../generated/worker");
class Notifier {
    static workerUrl = new URL(`data:text/javascript;base64,${worker_1.worker}`);
    static MANUAL_EXIT_CODE = 114514;
    worker;
    name;
    protocol;
    resource;
    listeners = {};
    getIndex = {};
    getQueue = new Set();
    constructor(options) {
        this.name = options.name;
        this.protocol = options.protocol;
        this.init();
    }
    getMessage(type) {
        switch (type) {
            case 'subscribe':
                return {
                    type,
                    value: {
                        name: this.name,
                        protocol: this.protocol,
                    },
                };
            case 'exit':
                return {
                    type,
                    value: Notifier.MANUAL_EXIT_CODE,
                };
            default:
                return undefined;
        }
    }
    init() {
        this.worker = new worker_threads_1.Worker(Notifier.workerUrl);
        this.worker
            ?.on('message', ({ resource, diff }) => {
            this.resource = resource;
            Object
                .entries(this.listeners)
                .forEach(([k, listeners]) => {
                const changed = Reflect.get(diff, k);
                if (changed !== false) {
                    const res = Reflect.get(resource, k)
                        || Reflect.get(resource, Tag_1.Tag.defaultEnvTag);
                    if (res) {
                        listeners.forEach(listener => listener(res));
                    }
                }
            });
            for (const cb of this.getQueue) {
                cb();
                this.getQueue.delete(cb);
            }
        })
            ?.on('error', e => {
            console.log('[hulk-xds] worker thread crashed with error: %s. rebooting...', e.message);
            this.init();
        })
            ?.on('exit', code => {
            if (code !== Notifier.MANUAL_EXIT_CODE) {
                console.log('[hulk-xds] worker thread exited with code: %s. rebooting...', code);
                this.init();
            }
            console.log('[hulk-xds] worker thread exited with code: %s.', code);
        })
            ?.postMessage(this.getMessage('subscribe'));
    }
    reportState(discoverTime) {
        hulk_metrics_1.MetricsService.observeDiscoverState({ upstream: this.name, discoverTime });
    }
    terminate() {
        this.worker?.postMessage(this.getMessage('exit'));
    }
    onUpdate({ envTag = Tag_1.Tag.envTag }, listener) {
        if (this.resource) {
            listener(Reflect.get(this.resource, envTag)
                || Reflect.get(this.resource, Tag_1.Tag.defaultEnvTag));
        }
        else {
            const existingListeners = Reflect.get(this.listeners, envTag);
            if (existingListeners) {
                existingListeners.push(listener);
            }
            else {
                Reflect.set(this.listeners, envTag, [listener]);
            }
        }
        return () => Reflect
            .set(this.listeners, envTag, Reflect
            .get(this.listeners, envTag)
            ?.filter(l => l !== listener));
    }
    roundRobin(envTag, loose) {
        if (this.resource) {
            const res = Reflect.get(this.resource, envTag);
            if (res?.length) {
                let index = Reflect.get(this.getIndex, envTag) ?? 0;
                if (index >= res.length) {
                    index = 0;
                }
                Reflect.set(this.getIndex, envTag, index + 1);
                return Reflect.get(res, index);
            }
            if (loose && envTag !== Tag_1.Tag.defaultEnvTag) {
                return this.roundRobin(Tag_1.Tag.defaultEnvTag);
            }
        }
        return undefined;
    }
    get({ envTag = Tag_1.Tag.envTag, timeout = 1000, loose = true, startTime = Date.now(), }) {
        const existing = this.roundRobin(envTag, loose);
        const discoverTime = Date.now() - startTime;
        if (existing) {
            this.reportState(discoverTime);
            return Promise.resolve(existing);
        }
        const restTime = timeout - discoverTime;
        return new Promise((resolve, reject) => {
            const cb = timeout > -1
                ? (() => {
                    const timer = setTimeout(() => {
                        reject(new Error(`[hulk-xds] discover ${this.name} timeout(${timeout}ms).`));
                        this.getQueue.delete(cb);
                    }, restTime);
                    return () => {
                        resolve(this.get({ envTag, timeout, startTime }));
                        clearTimeout(timer);
                    };
                })()
                : () => resolve(this.get({ envTag, timeout, startTime }));
            this.getQueue.add(cb);
        });
    }
}
exports.Notifier = Notifier;
