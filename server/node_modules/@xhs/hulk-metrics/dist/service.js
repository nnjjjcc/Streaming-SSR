"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetricsService = void 0;
const class_1 = require("./class");
class MetricsService {
    static ArtifactlabelNames = [
        'artifactName',
        'artifactVersion',
        'envTag',
    ];
    static labelNames = [
        ...MetricsService.ArtifactlabelNames,
        'type',
        'routerPath',
        'method',
        'path',
        'status',
        'code',
        'success',
        'downgrade',
        'detached',
    ];
    static upstreamingLabelNames = [
        ...MetricsService.labelNames,
        'upstream',
        'host',
    ];
    static apiCallsObserver = process.env.DISABLE_DEFAULT_METRICS !== 'true'
        ? class_1.Metrics.createObserver({
            name: 'nodejs_api_calls',
            help: 'monitor response time towards incoming api calls',
            labelNames: MetricsService.labelNames,
        })
        : undefined;
    static apiCallsSendTimeObserver = process.env.DISABLE_DEFAULT_METRICS !== 'true'
        ? class_1.Metrics.createObserver({
            name: 'nodejs_api_calls_send_time',
            help: 'monitor send time after respond towards incoming api calls',
            labelNames: MetricsService.labelNames,
        })
        : undefined;
    static apiCallsSizeObserver = process.env.DISABLE_DEFAULT_METRICS !== 'true'
        ? class_1.Metrics.createObserver({
            name: 'nodejs_api_calls_size',
            help: 'monitor size of html returned towards incoming api calls',
            labelNames: MetricsService.labelNames,
        })
        : undefined;
    static apiCallsRenderObserver = process.env.DISABLE_DEFAULT_METRICS !== 'true'
        ? class_1.Metrics.createObserver({
            name: 'nodejs_api_calls_render',
            help: 'monitor render time towards incoming api calls',
            labelNames: MetricsService.labelNames,
        })
        : undefined;
    static apiCallsRenderTimeObserver = process.env.DISABLE_DEFAULT_METRICS !== 'true'
        ? class_1.Metrics.createObserver({
            name: 'nodejs_api_calls_render_time',
            help: 'monitor render time towards incoming api calls when succeed',
            labelNames: MetricsService.labelNames,
        })
        : undefined;
    static apiCallsRenderErrorObserver = process.env.DISABLE_DEFAULT_METRICS !== 'true'
        ? class_1.Metrics.createObserver({
            name: 'nodejs_api_calls_render_error',
            help: 'monitor render error towards incoming api calls',
            labelNames: MetricsService.labelNames,
        })
        : undefined;
    static httpCallsObserver = process.env.DISABLE_DEFAULT_METRICS !== 'true'
        ? class_1.Metrics.createObserver({
            name: 'nodejs_http_calls',
            help: 'monitor response time towards outgoing http calls',
            labelNames: MetricsService.upstreamingLabelNames,
        })
        : undefined;
    static rpcCallsObserver = process.env.DISABLE_DEFAULT_METRICS !== 'true'
        ? class_1.Metrics.createObserver({
            name: 'nodejs_rpc_calls',
            help: 'monitor response time towards outgoing rpc calls',
            labelNames: MetricsService.upstreamingLabelNames,
        })
        : undefined;
    static dbCallsObserver = process.env.DISABLE_DEFAULT_METRICS !== 'true'
        ? class_1.Metrics.createObserver({
            name: 'nodejs_db_calls',
            help: 'monitor response time towards outgoing db calls',
            labelNames: MetricsService.upstreamingLabelNames,
        })
        : undefined;
    static connectionObserver = process.env.DISABLE_DEFAULT_METRICS !== 'true'
        ? class_1.Metrics.createObserver({
            name: 'nodejs_connection',
            help: 'monitor connection towards upstreams',
            labelNames: [...MetricsService.ArtifactlabelNames, 'upstream'],
        })
        : undefined;
    static discoverObserver = process.env.DISABLE_DEFAULT_METRICS !== 'true'
        ? class_1.Metrics.createObserver({
            name: 'nodejs_discover',
            help: 'monitor discover time towards upstreams',
            labelNames: [...MetricsService.ArtifactlabelNames, 'upstream'],
        })
        : undefined;
    static customMetrics = new Map();
    static register({ name, help = name, labelNames }) {
        MetricsService
            .customMetrics
            .set(name, class_1.Metrics.createObserver({
            name,
            help,
            labelNames: [
                ...MetricsService.labelNames,
                ...labelNames,
            ],
        }));
        return MetricsService;
    }
    static observeRenderState(state, source) {
        const { renderType: type, renderRoute: routerPath = source?.routerPath, renderSuccess, renderTime = -1, renderSize = -1, downgrade, detached, } = state;
        const labels = {
            routerPath,
            downgrade,
            detached: String(detached),
        };
        MetricsService.apiCallsRenderObserver?.looseObserve({ ...labels, type, success: String(renderSuccess) }, renderTime);
        if (renderSuccess) {
            if (renderTime >= 0) {
                MetricsService.apiCallsRenderTimeObserver?.looseObserve(labels, renderTime);
            }
            if (renderSize >= 0) {
                MetricsService.apiCallsSizeObserver?.looseObserve(labels, renderSize);
            }
        }
        else {
            MetricsService.apiCallsRenderErrorObserver?.looseObserve(labels, 1);
        }
    }
    static observeUpstreamingState(observer, state, source) {
        const { upstream, 
        /**
         * host is forbidden since it's high based
         * host,
         * */
        method, path, status, code, success, detached, responseTime = -1, } = state;
        if (responseTime >= 0) {
            observer
                ?.looseObserve({
                routerPath: source?.routerPath,
                upstream,
                method,
                path,
                status,
                code,
                success: String(success),
                detached: String(detached),
            }, responseTime);
        }
    }
    static observeHttpState(state, source) {
        MetricsService
            .observeUpstreamingState(MetricsService.httpCallsObserver, state, source);
    }
    static observeRpcState(state, source) {
        MetricsService
            .observeUpstreamingState(MetricsService.rpcCallsObserver, state, source);
    }
    static observeDbState(state, source) {
        MetricsService
            .observeUpstreamingState(MetricsService.dbCallsObserver, state, source);
    }
    static observeConnectionState({ count = -1, ...labels }) {
        if (count >= 0) {
            MetricsService.connectionObserver?.looseObserve(labels, count);
        }
    }
    static observeDiscoverState({ discoverTime = -1, ...labels }) {
        if (discoverTime >= 0) {
            MetricsService.discoverObserver?.looseObserve(labels, discoverTime);
        }
    }
    static observeCustomState({ name, labels, value = 1 }) {
        if (value >= 0) {
            MetricsService.customMetrics
                .get(name)
                ?.looseObserve(labels, value);
        }
    }
    static observe(ctx) {
        if ('success' in ctx.state) {
            const { renderType: type, method, path, status, code, success, responseTime = -1, sendTime = -1, downgrade, http, rpc, db, customMetrics, } = ctx.state;
            const labels = {
                method,
                path,
                status,
                code,
                success: String(success),
                downgrade,
                routerPath: ctx.state.renderRoute ?? path,
            };
            if (responseTime >= 0) {
                MetricsService.apiCallsObserver?.looseObserve({ ...labels, type }, responseTime);
            }
            if (sendTime >= 0) {
                MetricsService.apiCallsSendTimeObserver?.looseObserve(labels, sendTime);
            }
            if ('renderSuccess' in ctx.state) {
                MetricsService.observeRenderState(ctx.state, labels);
            }
            http
                ?.forEach(state => MetricsService.observeHttpState(state, labels));
            rpc
                ?.forEach(state => MetricsService.observeRpcState(state, labels));
            db
                ?.forEach(state => MetricsService.observeDbState(state, labels));
            if (customMetrics?.length) {
                customMetrics
                    .forEach(v => MetricsService.observeCustomState({ ...v, labels: { ...labels, ...v.labels } }));
            }
        }
    }
}
exports.MetricsService = MetricsService;
