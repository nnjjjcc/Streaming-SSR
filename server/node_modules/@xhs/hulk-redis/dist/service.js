"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Redis = void 0;
const hulk_xds_1 = require("@xhs/hulk-xds");
const hulk_metrics_1 = require("@xhs/hulk-metrics");
const class_1 = require("./class");
class Redis {
    static defaultOptions = { commandTimeout: 3 * 1000, connectionTimeout: 60 * 1000 };
    options;
    connections = new Map();
    constructor(options) {
        this.options = { ...Redis.defaultOptions, ...options };
    }
    static key({ ip, port }) {
        return `${ip}:${port}`;
    }
    reportState() {
        hulk_metrics_1.MetricsService.observeConnectionState({ upstream: this.options.name, count: this.connections.size });
    }
    getConnection() {
        return hulk_xds_1.EDS
            .get({ name: this.options.name, protocol: 'corvus', timeout: this.options.commandTimeout })
            .then(address => {
            const key = Redis.key(address);
            const existingConnection = this.connections.get(key);
            if (existingConnection) {
                return existingConnection;
            }
            const connection = new class_1.Connection({ ...this.options, ...address });
            this.connections.set(key, connection);
            this.reportState();
            connection
                .once('close', (message) => {
                this.connections.delete(key);
                this.reportState();
                console.log(`[hulk redis] connection to ${this.options.name}@${key} closed due to ${message}.`);
            });
            return connection;
        });
    }
    terminate() {
        this.connections.forEach(connnetion => connnetion.close('terminate'));
    }
    command(...parameters) {
        return Promise
            .race([
            this.getConnection()
                .then(connection => connection.command(...parameters)),
            new Promise((_, reject) => setTimeout(() => {
                reject(new Error(`[hulk redis] call ${this.options.name} timeout.`));
            }, this.options.commandTimeout)),
        ]);
    }
    /**
     *
     * https://redis.io/commands#generic
     *
     */
    /**
     * https://redis.io/commands/keys
     */
    keys(pattern = '*') {
        return this.command('KEYS', pattern);
    }
    /**
     * https://redis.io/commands/randomkey
     */
    randomkey() {
        return this.command('RANDOMKEY');
    }
    /**
     * https://redis.io/commands/type
     */
    type(key) {
        return this.command('TYPE', key);
    }
    /**
     * https://redis.io/commands/rename
     */
    rename(key, newKey) {
        return this.command('RENAME', key, newKey);
    }
    /**
     * https://redis.io/commands/renamenx
     */
    renamenx(key, newKey) {
        return this.command('RENAMENX', key, newKey);
    }
    /**
     * https://redis.io/commands/copy
     */
    copy(source, destination) {
        return this.command('COPY', source, destination);
    }
    /**
     * https://redis.io/commands/del
     */
    del(...keys) {
        return this.command('DEL', ...keys);
    }
    /**
     * https://redis.io/commands/unlink
     */
    unlink(...keys) {
        return this.command('UNLINK', ...keys);
    }
    /**
     * https://redis.io/commands/move
     */
    move(key, db) {
        return this.command('MOVE', key, db);
    }
    /**
     * https://redis.io/commands/exists
     */
    exists(...keys) {
        return this.command('EXISTS', ...keys);
    }
    /**
     * https://redis.io/commands/expire
     */
    expire(key, seconds) {
        return this.command('EXPIRE', key, seconds);
    }
    /**
     * https://redis.io/commands/pexpire
     */
    pexpire(key, milliseconds) {
        return this.command('PEXPIRE', key, milliseconds);
    }
    /**
     * https://redis.io/commands/expireat
     */
    expireat(key, secondsTimestamp) {
        return this.command('EXPIREAT', key, secondsTimestamp);
    }
    /**
     * https://redis.io/commands/pexpireat
     */
    pexpireat(key, millisecondsTimestamp) {
        return this.command('PEXPIREAT', key, millisecondsTimestamp);
    }
    /**
     * https://redis.io/commands/expiretime
     */
    expiretime(key) {
        return this.command('EXPIRETIME', key);
    }
    /**
     * https://redis.io/commands/expiretime
     */
    pexpiretime(key) {
        return this.command('PEXPIRETIME', key);
    }
    /**
     * https://redis.io/commands/ttl
     */
    ttl(key) {
        return this.command('TTL', key);
    }
    /**
     * https://redis.io/commands/pttl
     */
    pttl(key) {
        return this.command('PTTL', key);
    }
    /**
     * https://redis.io/commands/persist
     */
    persist(key) {
        return this.command('PERSIST', key);
    }
    /**
     *
     * https://redis.io/commands#string
     *
     */
    /**
     * https://redis.io/commands/set
     */
    set(key, value, ...options) {
        return options.length
            ? this.command('SET', key, value, ...options)
            : this.command('SET', key, value);
    }
    /**
     * https://redis.io/commands/setnx
     */
    setnx(key, value, ...options) {
        return options.length
            ? this.command('SETNX', key, value, ...options)
            : this.command('SETNX', key, value);
    }
    /**
     * https://redis.io/commands/setrange
     */
    setrange(key, offset, value) {
        return this.command('SETRANGE', key, offset, value);
    }
    /**
     * https://redis.io/commands/setex
     */
    setex(key, seconds, value) {
        return this.command('SETEX', key, seconds, value);
    }
    /**
     * https://redis.io/commands/psetex
     */
    psetex(key, milliseconds, value) {
        return this.command('PSETEX', key, milliseconds, value);
    }
    /**
     * https://redis.io/commands/mset
     */
    mset(obj) {
        const array = [];
        Object.entries(obj)
            .forEach(([k, v]) => array.push(k, v));
        return this.command('MSET', ...array);
    }
    /**
     * https://redis.io/commands/msetnx
     */
    msetnx(obj) {
        const array = [];
        Object.entries(obj)
            .forEach(([k, v]) => array.push(k, v));
        return this.command('MSETNX', ...array);
    }
    /**
     * https://redis.io/commands/get
     */
    get(key) {
        return this.command('GET', key);
    }
    /**
     * https://redis.io/commands/getex
     */
    getex(key, ...options) {
        return options.length
            ? this.command('GETEX', key, ...options)
            : this.command('GETEX', key);
    }
    /**
     * https://redis.io/commands/getdel
     */
    getdel(key) {
        return this.command('GETDEL', key);
    }
    /**
     * https://redis.io/commands/getrange
     */
    getrange(key, [start, end] = [0, -1]) {
        return this.command('GETRANGE', key, start, end);
    }
    /**
     * https://redis.io/commands/getset
     */
    getset(key, value) {
        return this.command('GETSET', key, value);
    }
    /**
     * https://redis.io/commands/mget
     */
    mget(...keys) {
        return this.command('MGET', ...keys);
    }
    /**
     * https://redis.io/commands/decr
     */
    decr(key) {
        return this.command('DECR', key);
    }
    /**
     * https://redis.io/commands/decrby
     */
    decrby(key, decrement) {
        return this.command('DECRBY', key, decrement);
    }
    /**
     * https://redis.io/commands/incr
     */
    incr(key) {
        return this.command('INCR', key);
    }
    /**
     * https://redis.io/commands/incrby
     */
    incrby(key, increment) {
        return this.command('INCRBY', key, increment);
    }
    /**
     * https://redis.io/commands/incrbyfloat
     */
    incrbyfloat(key, increment) {
        return this.command('INCRBYFLOAT', key, increment);
    }
    /**
     * https://redis.io/commands/strlen
     */
    strlen(key) {
        return this.command('STRLEN', key);
    }
    /**
     * https://redis.io/commands/append
     */
    append(key, value) {
        return this.command('APPEND', key, value);
    }
    /**
     * https://redis.io/commands#hash
     */
    /**
     * https://redis.io/commands/hset
     */
    hset(key, field, value) {
        return this.command('HSET', key, field, value);
    }
    /**
     * https://redis.io/commands/hsetnx
     */
    hsetnx(key, field, value) {
        return this.command('HSETNX', key, field, value);
    }
    /**
     * https://redis.io/commands/hmset
     */
    hmset(key, obj) {
        const array = [];
        Object.entries(obj)
            .forEach(([k, v]) => array.push(k, v));
        return this.command('HMSET', key, ...array);
    }
    /**
     * https://redis.io/commands/hget
     */
    hget(key, field) {
        return this.command('HGET', key, field);
    }
    /**
     * https://redis.io/commands/hgetall
     */
    hgetall(key) {
        return this.command('HGETALL', key)
            .then(res => Redis.Array2Object(res));
    }
    /**
     * https://redis.io/commands/hmget
     */
    hmget(key, ...fields) {
        return this.command('HMGET', key, ...fields);
    }
    /**
     * https://redis.io/commands/hdel
     */
    hdel(key, ...fields) {
        return this.command('HDEL', key, ...fields);
    }
    /**
     * https://redis.io/commands/hexists
     */
    hexists(key, field) {
        return this.command('HEXISTS', key, field);
    }
    /**
     * https://redis.io/commands/hkeys
     */
    hkeys(key) {
        return this.command('HKEYS', key);
    }
    /**
     * https://redis.io/commands/hvals
     */
    hvals(key) {
        return this.command('HVALS', key);
    }
    /**
     * https://redis.io/commands/hlen
     */
    hlen(key) {
        return this.command('HLEN', key);
    }
    /**
     * https://redis.io/commands/hstrlen
     */
    hstrlen(key, field) {
        return this.command('HSTRLEN', key, field);
    }
    /**
     * https://redis.io/commands/hincrby
     */
    hincrby(key, field, increment) {
        return this.command('HINCRBY', key, field, increment);
    }
    /**
     * https://redis.io/commands/hincrbyfloat
     */
    hincrbyfloat(key, field, increment) {
        return this.command('HINCRBYFLOAT', key, field, increment);
    }
    /**
     * https://redis.io/commands#list
     */
    /**
     * https://redis.io/commands/lrem
     */
    lrem(key, count, value) {
        return this.command('LREM', key, count, value);
    }
    /**
     * https://redis.io/commands/ltrim
     */
    ltrim(key, start, stop) {
        return this.command('LTRIM', key, start, stop);
    }
    /**
     * https://redis.io/commands/lset
     */
    lset(key, index, value) {
        return this.command('LSET', key, index, value);
    }
    /**
     * https://redis.io/commands/linsert
     */
    linsert(key, type, pivot, value) {
        return this.command('LINSERT', key, type, pivot, value);
    }
    /**
     * https://redis.io/commands/lpush
     */
    lpush(key, ...values) {
        return this.command('LPUSH', key, ...values);
    }
    /**
     * https://redis.io/commands/lpushx
     */
    lpushx(key, ...values) {
        return this.command('LPUSHX', key, ...values);
    }
    /**
     * https://redis.io/commands/rpush
     */
    rpush(key, ...values) {
        return this.command('RPUSH', key, ...values);
    }
    /**
     * https://redis.io/commands/rpushx
     */
    rpushx(key, ...values) {
        return this.command('RPUSHX', key, ...values);
    }
    /**
     * https://redis.io/commands/blmove
     */
    blmove(source, destination, ...options) {
        return this.command('BLMOVE', source, destination, ...options);
    }
    /**
     * https://redis.io/commands/lmove
     */
    lmove(source, destination, ...options) {
        return this.command('LMOVE', source, destination, ...options);
    }
    /**
     * https://redis.io/commands/blpop
     */
    blpop(timeout, ...keys) {
        return this.command('BLPOP', ...keys, timeout);
    }
    lpop(key, count) {
        return typeof count === 'number'
            ? this.command('LPOP', key, count)
            : this.command('LPOP', key);
    }
    /**
     * https://redis.io/commands/brpop
     */
    brpop(timeout, ...keys) {
        return this.command('BRPOP', ...keys, timeout);
    }
    rpop(key, count) {
        return typeof count === 'number'
            ? this.command('RPOP', key, count)
            : this.command('RPOP', key);
    }
    /**
     * https://redis.io/commands/lrange
     */
    lrange(key, start, stop) {
        return this.command('LRANGE', key, start, stop);
    }
    /**
     * https://redis.io/commands/lindex
     */
    lindex(key, index) {
        return this.command('LINDEX', key, index);
    }
    /**
     * https://redis.io/commands/lpos
     */
    lpos(key, value, ...options) {
        return options.length
            ? this.command('LPOS', key, value, ...options)
            : this.command('LPOS', key, value);
    }
    /**
     * https://redis.io/commands/llen
     */
    llen(key) {
        return this.command('LLEN', key);
    }
    /**
     * https://redis.io/commands#set
     */
    /**
     * https://redis.io/commands/sadd
     */
    sadd(key, ...members) {
        return this.command('SADD', key, ...members);
    }
    /**
     * https://redis.io/commands/scard
     */
    scard(key) {
        return this.command('SCARD', key);
    }
    /**
     * https://redis.io/commands/sdiff
     */
    sdiff(key, ...keys) {
        return this.command('SDIFF', key, ...keys);
    }
    /**
     * https://redis.io/commands/sdiffstore
     */
    sdiffstore(destination, key, ...keys) {
        return this.command('SDIFFSTORE', destination, key, ...keys);
    }
    /**
     * https://redis.io/commands/sinter
     */
    sinter(key, ...keys) {
        return this.command('SINTER', key, ...keys);
    }
    /**
     * https://redis.io/commands/sinterstore
     */
    sinterstore(destination, key, ...keys) {
        return this.command('SINTERSTORE', destination, key, ...keys);
    }
    /**
     * https://redis.io/commands/sismember
     */
    sismember(key, member) {
        return this.command('SISMEMBER', key, member);
    }
    /**
     * https://redis.io/commands/smismember
     */
    smismember(key, ...members) {
        return this.command('SMISMEMBER', key, ...members);
    }
    /**
     * https://redis.io/commands/smembers
     */
    smembers(key) {
        return this.command('SMEMBERS', key);
    }
    /**
     * https://redis.io/commands/smove
     */
    smove(source, destination, member) {
        return this.command('SMOVE', source, destination, member);
    }
    spop(key, count) {
        return typeof count === 'number'
            ? this.command('SPOP', key, count)
            : this.command('SPOP', key);
    }
    srandmember(key, count) {
        return typeof count === 'number'
            ? this.command('SRANDMEMBER', key, count)
            : this.command('SRANDMEMBER', key);
    }
    /**
     * https://redis.io/commands/srem
     */
    srem(key, ...members) {
        return this.command('SREM', key, ...members);
    }
    /**
     * https://redis.io/commands/sunion
     */
    sunion(...keys) {
        return this.command('SUNION', ...keys);
    }
    /**
     * https://redis.io/commands/sunionstore
     */
    sunionstore(destination, ...keys) {
        return this.command('SUNIONSTORE', destination, ...keys);
    }
    /**
     * https://redis.io/commands#sorted_set
    */
    /**
     * https://redis.io/commands/zrem
     */
    zrem(key, ...members) {
        return this.command('ZREM', key, ...members);
    }
    /**
     * https://redis.io/commands/zadd
     */
    zadd(key, memberscore, ...options) {
        const array = Object.entries(memberscore)
            .reduce((a, [member, score]) => {
            a.push(score, member);
            return a;
        }, []);
        return options.length
            ? this.command('ZADD', key, ...options, ...array)
            : this.command('ZADD', key, ...array);
    }
    /**
     * https://redis.io/commands/zcard
     */
    zcard(key) {
        return this.command('ZCARD', key);
    }
    /**
     * https://redis.io/commands/zcount
     */
    zcount(key, min, max) {
        return this.command('ZCOUNT', key, min, max);
    }
    /**
     * https://redis.io/commands/zlexcount
     */
    zlexcount(key, min, max) {
        return this.command('ZLEXCOUNT', key, min, max);
    }
    /**
     * https://redis.io/commands/zincrby
     */
    zincrby(key, increment, member) {
        return this.command('ZINCRBY', key, increment, member);
    }
    /**
     * https://redis.io/commands/zpopmax
     */
    zpopmax(key) {
        return this.command('ZPOPMAX', key)
            .then(([member, score]) => ({ [member]: score }));
    }
    /**
     * https://redis.io/commands/zpopmin
     */
    zpopmin(key) {
        return this.command('ZPOPMIN', key)
            .then(([member, score]) => ({ [member]: score }));
    }
    /**
     * https://redis.io/commands/zscore
     */
    zscore(key, member) {
        return this.command('ZSCORE', key, member);
    }
    /**
     * https://redis.io/commands/zmscore
     */
    zmscore(key, ...member) {
        return this.command('ZMSCORE', key, ...member);
    }
    /**
     * https://redis.io/commands/zrank
     */
    zrank(key, member) {
        return this.command('ZRANK', key, member);
    }
    /**
     * https://redis.io/commands/zrange
     */
    zrange(key, min, max, ...options) {
        return this.command('ZRANGE', key, min, max, ...options);
    }
    zrangewithscores(key, min, max, ...options) {
        return this.command('ZRANGE', key, min, max, ...options, 'WITHSCORES')
            .then(res => Redis.Array2Object(res));
    }
    static Array2Object(array) {
        const obj = {};
        for (let i = 0; i < array.length; i++) {
            // eslint-disable-next-line no-plusplus
            obj[array[i]] = array[++i];
        }
        return obj;
    }
}
exports.Redis = Redis;
