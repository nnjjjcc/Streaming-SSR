"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Connection = void 0;
const events_1 = require("events");
const net_1 = require("net");
const tls_1 = require("tls");
const Proto_1 = require("./Proto");
class Connection extends events_1.EventEmitter {
    socket;
    proto = new Proto_1.Proto();
    commandQueue = [];
    connecting = false;
    idle = true;
    constructor({ ip, port, password, connectionTimeout, tls, }) {
        super();
        if (tls) {
            const { key, cert } = tls;
            this.socket = (0, tls_1.connect)({
                host: ip, port, key, cert,
            });
        }
        else {
            this.socket = (0, net_1.createConnection)({ host: ip, port });
        }
        this.socket
            .once('error', e => this.close('error', e))
            .once('close', () => this.close('close'))
            .once('timeout', () => this.close('timeout'))
            .once('end', () => this.close('end'))
            .once('connect', () => {
            this.connecting = true;
            this.coordinate();
            if (connectionTimeout) {
                this.socket.setTimeout(connectionTimeout);
            }
        })
            .on('data', buffer => {
            const { done, value: { error, data } } = this.proto
                .write(buffer)
                .parse();
            if (done) {
                this.commandQueue
                    .shift()
                    ?.callback(error, data);
                this.coordinate();
            }
        });
        if (password) {
            this.command('AUTH', password)
                .catch((e) => this.close(e?.message));
        }
    }
    coordinate(command) {
        if (command) {
            this.commandQueue.push(command);
            if (this.connecting && this.idle) {
                this.idle = false;
                this.socket.write(command.message);
            }
        }
        else {
            const [nextCommand] = this.commandQueue;
            if (nextCommand) {
                this.socket.write(nextCommand.message);
            }
            else {
                this.idle = true;
            }
        }
    }
    command(...parameters) {
        return new Promise((resolve, reject) => {
            const command = {
                message: Proto_1.Proto.encode(...parameters),
                callback: (err, data) => (err ? reject : resolve)(data),
            };
            this.coordinate(command);
        });
    }
    close(message, e) {
        this.socket.destroy();
        this.emit('close', message);
        if (e) {
            console.log(`[hulk redis] connection error: ${e.message}`);
        }
    }
}
exports.Connection = Connection;
